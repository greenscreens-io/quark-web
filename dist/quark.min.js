/* Quark Engine v2.1.0 (c) Green Screens Ltd. */
class Events{constructor(){this.listeners=new Map,this.onceListeners=new Map,this.triggers=new Map}_checkPast(label,callback){return!!this.triggers.has(label)&&(callback(this.triggers.get(label)),!0)}on(label,callback,checkPast=!1){this.listeners.has(label)||this.listeners.set(label,[]),this.listeners.get(label).push(callback),checkPast&&this._checkPast(label,callback)}onReady(label,callback){this.on(label,callback,!0)}once(label,callback,checkPast=!1){this.onceListeners.has(label)||this.onceListeners.set(label,[]),checkPast&&this._checkPast(label,callback)||this.onceListeners.get(label).push(callback)}onceReady(label,callback){this.once(label,callback,!0)}off(label,callback=!0){if(!0===callback)this.removeAllListeners(label);else{let _off=inListener=>{let listeners=inListener.get(label);listeners&&inListener.set(label,listeners.filter(value=>!(value===callback)))};_off(this.listeners),_off(this.onceListeners)}}removeAllListeners(label){this.listeners.delete(label),this.onceListeners.delete(label)}trigger(label,...args){this.emit(label,...args)}emit(label,...args){let res=!1;this.triggers.set(label,...args);let _trigger=(inListener,label,...args)=>{let listeners=inListener.get(label);listeners&&listeners.length&&(listeners.forEach(listener=>{listener(...args)}),res=!0)};return _trigger(this.onceListeners,label,...args),_trigger(this.listeners,label,...args),this.onceListeners.delete(label),res}}class Buffer{static from(value,type){switch(type){case"base64":return Buffer.fromBase64(value);case"hex":return Buffer.fromHex(value)}return value}static to(value,type){switch(type){case"base64":return Buffer.toBase64(value);case"hex":return Buffer.toHex(value)}return value}static fromHex(value){let arry=[];for(let i=0;i<value.length;i+=2)arry.push(parseInt("0x"+value.substr(i,2),16));return new Uint8Array(arry)}static fromBase64(value){let strbin=atob(value),buffer=new ArrayBuffer(strbin.length),bufView=new Uint8Array(buffer);for(let i=0,strLen=strbin.length;i<strLen;i++)bufView[i]=strbin.charCodeAt(i);return bufView}static toHex(buffer){return Array.prototype.map.call(new Uint8Array(buffer),x=>("00"+x.toString(16)).slice(-2)).join("")}static toBase64(buffer){return btoa(new Uint8Array(buffer))}}class Queue extends Map{constructor(){super();this.up=0,this.down=0,this.tid=0}updateRequest(req,callback){this.tid++,this.up++,req.tid=this.tid.toString(),this.set(req.tid,callback)}reset(){let me=this;me.up>50&&me.down>=me.up&&(me.up=0,me.down=0)}process(obj){let me=this,unknown=[];if(Array.isArray(obj))obj.forEach(o=>{let res=me.execute(o);res&&unkown.push(res)});else{let o=me.execute(obj);o&&unknown.push(o)}return unknown}execute(obj){let me=this,tid=obj.tid,unknown=null;if(me.down++,me.has(tid))try{me.get(tid)(null,obj)}catch(e){console.log(e),me.get(tid)(e,null)}finally{me.delete(tid)}else unknown=obj;return me.reset(),unknown}}class Streams{static get isAvailable(){return"undefined"!=typeof CompressionStream&&"undefined"!=typeof DecompressionStream}static async compress(text,encoding="gzip"){let byteArray=(new TextEncoder).encode(text),cs=new CompressionStream(encoding),writer=cs.writable.getWriter();return writer.write(byteArray),writer.close(),new Response(cs.readable).arrayBuffer()}static async decompress(byteArray,encoding="gzip"){let cs=new DecompressionStream(encoding),writer=cs.writable.getWriter();writer.write(byteArray),writer.close();let arrayBuffer=await new Response(cs.readable).arrayBuffer();return(new TextDecoder).decode(arrayBuffer)}}class Security{constructor(){let me=this;me.VERSION=0,me.encKEY=null,me.aesKEY=null,me.exportedAES=null,me.encoder=new TextEncoder,me.decoder=new TextDecoder}getChallenge(cfg){return[cfg.challenge||"",cfg.keyEnc||"",cfg.keyVer||""].join("")}getRandom(size){let array=new Uint8Array(size);return crypto.getRandomValues(array),array}async generateAesKey(){return crypto.subtle.generateKey({name:"AES-CTR",length:128},!0,["encrypt","decrypt"])}async exportAesKey(key){let buffer=await crypto.subtle.exportKey("raw",key);return new Uint8Array(buffer)}async importRsaKey(key,type,mode){let binaryDer=Buffer.from(key,"base64");return crypto.subtle.importKey("spki",binaryDer,type,!0,[mode])}async verify(key,signature,challenge){let binSignature=Buffer.from(signature,"base64"),binChallenge=this.encoder.encode(challenge);return crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-384"}},key,binSignature,binChallenge)}async encryptRSA(data){let me=this,encoded=data;return"string"==typeof data&&(encoded=me.encoder.encode(data)),crypto.subtle.encrypt("RSA-OAEP",me.encKEY,encoded)}async encryptAesMessage(key,iv,data){let encoded=this.encoder.encode(data),type={name:"AES-CTR",counter:iv,length:128};return crypto.subtle.encrypt(type,key,encoded)}async decryptAesMessage(key,iv,data){let databin=Buffer.from(data,"hex"),type={name:"AES-CTR",counter:Buffer.from(iv,"hex"),length:128};return crypto.subtle.decrypt(type,key,databin)}get isValid(){return null!==this.encKEY&&null!==this.aesKEY}static get isAvailable(){return null!=crypto.subtle}async init(cfg){let me=this;if(!Security.isAvailable)return void console.log("Security mode not available, TLS protocol required.");console.log("Security Initializing..."),me.VERSION++,me.encKEY=await me.importRsaKey(cfg.keyEnc,{name:"RSA-OAEP",hash:"SHA-256"},"encrypt"),me.aesKEY=await me.generateAesKey(),me.exportedAES=await me.exportAesKey(me.aesKEY);let verKey=await me.importRsaKey(cfg.keyVer,{name:"ECDSA",namedCurve:"P-384"},"verify");if(!await me.verify(verKey,cfg.signature,me.getChallenge(cfg||{})))throw me.encKEY=null,me.aesKEY=null,me.exportedAES=null,new Error("Signature invalid");console.log("Security Initialized!")}async encrypt(data,bin){let me=this,iv=me.getRandom(16),key=new Uint8Array(iv.length+me.exportedAES.length);key.set(iv),key.set(me.exportedAES,iv.length);let str="string"==typeof data?data:JSON.stringify(data),encryptedKey=await me.encryptRSA(key),encryptedData=await me.encryptAesMessage(me.aesKEY,iv,str);return!0===bin?{d:encryptedData,k:encryptedKey}:{d:Buffer.to(encryptedData,"hex"),k:Buffer.to(encryptedKey,"hex")}}async decrypt(cfg){let iv=cfg.iv,data=cfg.d,message=await this.decryptAesMessage(this.aesKEY,iv,data),str=this.decoder.decode(message),obj=JSON.parse(str);return obj&&"ws"==obj.type&&"data"===obj.cmd&&(obj=obj.data),obj}static async init(cfg){let security=new Security;return await security.init(cfg),security}}class Generator extends Events{constructor(){super(),this._model={}}get api(){return this._model}stop(){this.removeAllListeners("call"),this.removeAllListeners("api"),this.detach()}detach(){let root="undefined"==typeof global?self:global;Object.keys(this._model).forEach(v=>root[v]=null),this._model={}}attach(){let root="undefined"==typeof global?self:global;Object.entries(this._model).forEach(v=>root[v[0]]=v[1])}build(o){let data=o?o.api||o:null;return data?(this._buildAPI(data),this.attach(),data):data}_buildAPI(cfg){let me=this;Array.isArray(cfg)?cfg.every(v=>(me._buildInstance(v),!0)):me._buildInstance(cfg)}_buildInstance(api){let me=this,tree=null,action=null;tree=me._buildNamespace(api.namespace),tree[api.action]||(tree[api.action]={}),action=tree[api.action],api.methods.every(v=>(me._buildMethod(api.namespace,api.action,action,v),!0))}_buildNamespace(namespace){let me=this,tmp=null;return namespace.split(".").every(v=>(tmp?(tmp[v]||(tmp[v]={}),tmp=tmp[v]):(me._model[v]||(me._model[v]={}),tmp=me._model[v]),!0)),tmp}_buildMethod(namespace,action,instance,api){let enc=!1!==api.encrypt,cfg={n:namespace,c:action,m:api.name,l:api.len,e:enc};instance[api.name]=this._apiFn(cfg)}_apiFn(params){let me=this,prop=params;return function fn(){let args,req,promise=null;return args=Array.prototype.slice.call(arguments),req={namespace:prop.n,action:prop.c,method:prop.m,e:prop.e,data:args},promise=new Promise((resolve,reject)=>{me.emit("call",req,(err,obj)=>{me._onResponse(err,obj,prop,resolve,reject)})}),promise}}_onResponse(err,obj,prop,response,reject){if(err)return void reject(err);prop.c===obj.action&&prop.m===obj.method&&obj.result&&obj.result.success?response(obj.result):reject(obj.result||obj)}static async build(cfg){let generator=new Generator;return generator.build(cfg),generator}}class WebChannel{async init(engine){let me=this;me.engine&&me.stop(),me.engine=engine;let generator=engine.Generator,data=await me.getAPI(engine.apiURL);await engine.registerAPI(data),engine.isSockChannel||generator.on("call",me.onRequest.bind(me))}stop(){let engine=this.engine;this.engine=null,engine.Generator.off("call"),engine.isSockChannel||fetch(engine.serviceURL,{method:"delete"})}async onRequest(req,callback){let me=this,o=null,e=null;try{o=await me.onCall(me.engine,req)}catch(err){e=err}callback(e,o)}async getAPI(url){let service=url,id=Date.now(),resp=await fetch(service,{method:"get",headers:{"x-time":id}}),data=await resp.json();return data.challenge=id.toString(),data}async fetchCall(url,data){let MIME="application/json",req={method:"post",headers:{Accept:MIME,"Content-Type":MIME},body:JSON.stringify(data)},res=await fetch(url,req);return await res.json()}async onCall(engine,req){let security=engine.Security,url=engine.serviceURL,hasArgs=Array.isArray(req.data)&&req.data.length>0,data=req;if(security.isValid&&hasArgs&&(data=await security.encrypt(req)),data=await this.fetchCall(url,data),"err"==data.cmd)throw new Error(data.result.msg);if("enc"===data.cmd){if(!security.isValid)throw new Error("Security available on https/wss only");data=await security.decrypt(data)}return data}}class SocketChannel extends Events{constructor(){super();this.queue=new Queue,this.webSocket=null,this.engine=null}async init(engine){let me=this;return me.stop(),me.engine=engine,new Promise((resolve,reject)=>(me._startSocket(resolve,reject),null))}stop(){return null!=this.webSocket&&(this.webSocket.close(),this.webSocket=null,this.engine=null,!0)}canEncrypt(req){let hasArgs=Array.isArray(req.data)&&req.data.length>0&&!1!==req.e;return this.engine.Security.isValid&&hasArgs}async onCall(req,callback){let me=this,msg=null,enc=null,data=null,isEncrypt=me.canEncrypt(req);if(me.queue.updateRequest(req,callback),isEncrypt&&(enc=await me.engine.Security.encrypt(req.data),req.data=[enc]),data={cmd:isEncrypt?"enc":"data",type:"ws",data:[req]},msg=JSON.stringify(data),!Streams.isAvailable)return me.webSocket.send(msg);msg=await Streams.compress(msg),me.webSocket.send(msg)}async _startSocket(resolve,reject){let me=this,engine=me.engine,generator=engine.Generator,challenge=Date.now(),url=`${engine.serviceURL}?q=${challenge}&c=${Streams.isAvailable}`;me.webSocket=new WebSocket(url,["ws4is"]),me.webSocket.binaryType="arraybuffer";let onCall=me.onCall.bind(me);me.webSocket.onopen=event=>{if(me.emit("online",event),generator.on("call",onCall),!engine.isWSAPI)return resolve(!0);generator.once("api",async data=>{try{data.challenge=challenge,await engine.registerAPI(data),resolve(!0)}catch(e){reject(e)}})},me.webSocket.onclose=event=>{generator.off("call",onCall),me.stop(),me.emit("offline",event)},me.webSocket.onerror=event=>{generator.off("call",onCall),reject(event),me.stop(),me.emit("error",event)},me.webSocket.onmessage=event=>{me._prepareMessage(event.data)}}async _prepareMessage(message){let me=this,obj=null,generator=me.engine.Generator;try{if(message instanceof ArrayBuffer){let text=await Streams.decompress(message);obj=JSON.parse(text)}"string"==typeof message&&(obj=JSON.parse(message)),obj?me.onMessage(obj):generator.emit("error",event)}catch(e){generator.emit("error",e)}}async onMessage(obj){let me=this,data=null,engine=me.engine,generator=engine.Generator,security=engine.Security;if("api"===obj.cmd)return generator.emit("api",obj.data);if("err"===obj.cmd)return generator.emit("error",obj.result);if("enc"===obj.cmd){if(!Security.isAvailable)return generator.emit("error",new Error("Security available on https/wss only"));data=await security.decrypt(obj)}if("data"===obj.cmd&&(data=obj.data),data){me.queue.process(data).forEach(obj=>me.emit("message",obj))}else me.emit("message",data)}}const ERROR_MESSAGE="Invalid definition for Engine Remote Service",ERROR_API_UNDEFIEND="API Url not defined!",ERROR_SVC_UNDEFIEND="Service Url not defined!";class Engine{constructor(cfg){if(!(cfg=cfg||{}).api)throw new Error(ERROR_API_UNDEFIEND);if(!cfg.service)throw new Error(ERROR_SVC_UNDEFIEND);let me=this;if(me.cfg=null,me.isWSAPI=!1,me.isWebChannel=!1,me.isSockChannel=!1,me.Security=null,me.Generator=null,me.WebChannel=null,me.SocketChannel=null,me.cfg=cfg,me.isWSAPI=cfg.api===cfg.service&&0==cfg.api.indexOf("ws"),me.isWebChannel=0===cfg.service.indexOf("http"),me.isSockChannel=0===cfg.service.indexOf("ws"),!1===(me.isWebChannel||me.isSockChannel))throw new Error(ERROR_MESSAGE)}async init(){let me=this;me.isActive||(me.Security=new Security,me.Generator=new Generator,(me.isWebChannel||0==me.isWSAPI)&&(me.WebChannel=new WebChannel,await me.WebChannel.init(me)),me.isSockChannel&&(me.SocketChannel=new SocketChannel,await me.SocketChannel.init(me)))}async registerAPI(data){let me=this;data.signature&&(me.Security.isActive||await me.Security.init(data)),me.Generator.build(data.api)}stop(){let me=this;me.WebChannel&&me.WebChannel.stop(),me.SocketChannel&&me.SocketChannel.stop(),me.Generator&&me.Generator.stop(),me.WebChannel=null,me.SocketChannel=null,me.Generator=null,me.Security=null,me.cfg=null}get api(){return this.Generator?this.Generator.api:null}get isActive(){return this.api&&this.Security}get apiURL(){return this.cfg?this.cfg.api:null}get serviceURL(){return this.cfg?this.cfg.service:null}static async init(cfg){let engine=new Engine(cfg);return await engine.init(),engine}}