class Buffer{static from(r,t){switch(t){case"base64":return Buffer.fromBase64(r);case"hex":return Buffer.fromHex(r)}return r}static to(r,t){switch(t){case"base64":return Buffer.toBase64(r);case"hex":return Buffer.toHex(r)}return r}static fromHex(r){let t=[];for(let e=0;e<r.length;e+=2)t.push(parseInt("0x"+r.substr(e,2),16));return new Uint8Array(t)}static fromBase64(r){const t=atob(r),e=new ArrayBuffer(t.length),a=new Uint8Array(e);for(let r=0,e=t.length;r<e;r++)a[r]=t.charCodeAt(r);return a}static toHex(r){return Array.prototype.map.call(new Uint8Array(r),(r=>("00"+r.toString(16)).slice(-2))).join("")}static toBase64(r){return btoa(new Uint8Array(r))}}
class Events{constructor(){this.listeners=new Map,this.onceListeners=new Map,this.triggers=new Map}_checkPast(e,s){return!!this.triggers.has(e)&&(s(this.triggers.get(e)),!0)}on(e,s,t=!1){const n=this;n.listeners.has(e)||n.listeners.set(e,[]),n.listeners.get(e).push(s),t&&n._checkPast(e,s)}onReady(e,s){this.on(e,s,!0)}once(e,s,t=!1){const n=this;n.onceListeners.has(e)||n.onceListeners.set(e,[]),t&&n._checkPast(e,s)||n.onceListeners.get(e).push(s)}onceReady(e,s){this.once(e,s,!0)}off(e,s=!0){const t=this;if(!0===s)t.removeAllListeners(e);else{let n=t=>{const n=t.get(e);n&&t.set(e,n.filter((e=>e!==s)))};n(t.listeners),n(t.onceListeners)}}removeAllListeners(e){this.listeners.delete(e),this.onceListeners.delete(e)}trigger(e,...s){this.emit(e,...s)}emit(e,...s){const t=this;t.triggers.set(e,...s);const n=(e,s,...t)=>{const n=e.get(s);if(n&&n.length)return n.forEach((e=>{e(...t)})),!0};let i=n(t.onceListeners,e,...s);return i=i||n(t.listeners,e,...s),t.onceListeners.delete(e),i}}
class Queue extends Map{constructor(){super();const t=this;t.up=0,t.down=0,t.tid=0}updateRequest(t,e){const s=this;s.tid++,s.up++,t.tid=s.tid.toString(),s.set(t.tid,e)}reset(){const t=this;t.up>50&&t.down>=t.up&&(t.up=0,t.down=0)}process(t){const e=this,s=[];if(Array.isArray(t))t.forEach((t=>{const s=e.execute(t);s&&unkown.push(s)}));else{const n=e.execute(t);n&&s.push(n)}return s}execute(t){const e=this,s=t.tid;let n=null;if(e.down++,e.has(s))try{e.get(s)(null,t)}catch(t){console.log(t),e.get(s)(t,null)}finally{e.delete(s)}else n=t;return e.reset(),n}}
class Streams{static get isAvailable(){return"undefined"!=typeof CompressionStream&&"undefined"!=typeof DecompressionStream}static async compress(e,r="gzip"){const t=(new TextEncoder).encode(e),s=new CompressionStream(r),n=s.writable.getWriter();return n.write(t),n.close(),new Response(s.readable).arrayBuffer()}static async decompress(e,r="gzip"){const t=new DecompressionStream(r),s=t.writable.getWriter();s.write(e),s.close();const n=await new Response(t.readable).arrayBuffer();return(new TextDecoder).decode(n)}}
class Security{constructor(){const e=this;e.VERSION=0,e.encKEY=null,e.aesKEY=null,e.exportedAES=null,e.encoder=new TextEncoder,e.decoder=new TextDecoder}getChallenge(e){return[e.challenge||"",e.keyEnc||"",e.keyVer||""].join("")}getRandom(e){const t=new Uint8Array(e);return crypto.getRandomValues(t),t}async generateAesKey(){return crypto.subtle.generateKey({name:"AES-CTR",length:128},!0,["encrypt","decrypt"])}async exportAesKey(e){const t=await crypto.subtle.exportKey("raw",e);return new Uint8Array(t)}async importRsaKey(e,t,n){const r=Buffer.from(e,"base64");return crypto.subtle.importKey("spki",r,t,!0,[n])}async verify(e,t,n){const r=Buffer.from(t,"base64"),s=this.encoder.encode(n);return crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-384"}},e,r,s)}async encryptRSA(e){let t=e;return"string"==typeof e&&(t=this.encoder.encode(e)),crypto.subtle.encrypt("RSA-OAEP",this.encKEY,t)}async encryptAesMessage(e,t,n){const r=this.encoder.encode(n),s={name:"AES-CTR",counter:t,length:128};return crypto.subtle.encrypt(s,e,r)}async decryptAesMessage(e,t,n){const r=Buffer.from(n,"hex"),s={name:"AES-CTR",counter:Buffer.from(t,"hex"),length:128};return crypto.subtle.decrypt(s,e,r)}get isValid(){return null!==this.encKEY&&null!==this.aesKEY}static get isAvailable(){return null!=crypto.subtle}async init(e){const t=this;if(!Security.isAvailable)return void console.log("Security mode not available, TLS protocol required.");console.log("Security Initializing..."),t.VERSION++,t.encKEY=await t.importRsaKey(e.keyEnc,{name:"RSA-OAEP",hash:"SHA-256"},"encrypt"),t.aesKEY=await t.generateAesKey(),t.exportedAES=await t.exportAesKey(t.aesKEY);const n=await t.importRsaKey(e.keyVer,{name:"ECDSA",namedCurve:"P-384"},"verify");if(!await t.verify(n,e.signature,t.getChallenge(e||{})))throw t.encKEY=null,t.aesKEY=null,t.exportedAES=null,new Error("Signature invalid");console.log("Security Initialized!")}async encrypt(e,t){const n=this,r=n.getRandom(16),s=new Uint8Array(r.length+n.exportedAES.length);s.set(r),s.set(n.exportedAES,r.length);const a="string"==typeof e?e:JSON.stringify(e),c=await n.encryptRSA(s),o=await n.encryptAesMessage(n.aesKEY,r,a);return!0===t?{t:"1",d:o,k:c}:{t:"1",d:Buffer.to(o,"hex"),k:Buffer.to(c,"hex")}}async decrypt(e){const t=this,n=e.iv,r=e.d,s=await t.decryptAesMessage(t.aesKEY,n,r),a=t.decoder.decode(s);let c=JSON.parse(a);return c&&"ws"==c.type&&"data"===c.cmd&&(c=c.data),c}static async init(e){const t=new Security;return await t.init(e),t}}
class Generator extends Events{constructor(){super(),this._model={}}get api(){return this._model}stop(){const e=this;e.removeAllListeners("call"),e.removeAllListeners("api"),e.detach()}detach(){const e="undefined"==typeof global?self:global;Object.keys(this._model).forEach((t=>e[t]=null)),this._model={}}attach(){const e="undefined"==typeof global?self:global;Object.entries(this._model).forEach((t=>e[t[0]]=t[1]))}build(e){const t=e?e.api||e:null;return t?(this._buildAPI(t),this.attach(),t):t}_buildAPI(e){const t=this;Array.isArray(e)?e.forEach((e=>t._buildInstance(e))):t._buildInstance(e)}_buildInstance(e){const t=this;let n=null,s=null;n=t._buildNamespace(e.namespace),n[e.action]||(n[e.action]={}),s=n[e.action],e.methods.forEach((n=>t._buildMethod(e.namespace,e.action,s,n)))}_buildNamespace(e){const t=this;let n=null;return e.split(".").every((e=>(n?(n[e]||(n[e]={}),n=n[e]):(t._model[e]||(t._model[e]={}),n=t._model[e]),!0))),n}_buildMethod(e,t,n,s){const l=!1!==s.encrypt,o={n:e,c:t,m:s.name,l:s.len,e:l};n[s.name]=this._apiFn(o)}_apiFn(e){const t=this,n=e;return function(){let e,s,l=null;return e=Array.prototype.slice.call(arguments),s={namespace:n.n,action:n.c,method:n.m,e:n.e,data:e,ts:Date.now()},l=new Promise(((e,l)=>{t.emit("call",s,((s,o)=>{t._onResponse(s,o,n,e,l)}))})),l}}_onResponse(e,t,n,s,l){e?l(e):n.c===t.action&&n.m===t.method&&t.result&&t.result.success?s(t.result):l(t.result||t)}static async build(e){const t=new Generator;return t.build(e),t}}
class WebChannel{async init(e){const t=this;t.engine&&t.stop(),t.engine=e;const n=e.Generator,a=await t.getAPI(e.apiURL);await e.registerAPI(a),e.isSockChannel||n.on("call",t.onRequest.bind(t))}stop(){const e=this.engine;this.engine=null,e.Generator.off("call"),e.isSockChannel||fetch(e.serviceURL,{method:"delete"})}async onRequest(e,t){const n=this;let a=null,i=null;try{a=await n.onCall(n.engine,e)}catch(e){i=e}t(i,a)}async getAPI(e){const t=e,n=this.engine,a=Date.now(),i=Object.assign({},n.headers||{},{"x-time":a}),s=await fetch(t,{method:"get",headers:i}),r=await s.json();return r.challenge=a.toString(),r}async fetchCall(e,t){const n=this.engine,a="application/json",i={Accept:a,"Content-Type":a},s={method:"post",headers:Object.assign({},n.headers||{},i),body:JSON.stringify(t)},r=await fetch(e,s);return await r.json()}async onCall(e,t){const n=e.Security,a=e.serviceURL,i=Array.isArray(t.data)&&t.data.length>0;let s=t;if(n.isValid&&i&&(s=await n.encrypt(t)),s=await this.fetchCall(a,s),"err"==s.cmd)throw new Error(s.result.msg);if("enc"===s.cmd){if(!n.isValid)throw new Error("Security available on https/wss only");s=await n.decrypt(s)}return s}}
class SocketChannel extends Events{constructor(){super();const e=this;e.queue=new Queue,e.webSocket=null,e.engine=null}async init(e){const t=this;return t.stop(),t.engine=e,new Promise(((e,n)=>(t._startSocket(e,n),null)))}get isOpen(){const e=this;return null!=e.webSocket&&e.webSocket.readyState===e.webSocket.OPEN}stop(){let e=this;return null!=e.webSocket&&(e.webSocket.close(),e.webSocket=null,e.engine=null,!0)}canEncrypt(e){const t=Array.isArray(e.data)&&e.data.length>0&&!1!==e.e;return this.engine.Security.isValid&&t}async onCall(e,t){const n=this;let r=null,s=null,a=null;const i=n.canEncrypt(e);if(n.queue.updateRequest(e,t),i&&(s=await n.engine.Security.encrypt(e.data),e.data=[s]),a={cmd:i?"enc":"data",type:"ws",data:[e]},r=JSON.stringify(a),!Streams.isAvailable)return n.webSocket.send(r);r=await Streams.compress(r),n.webSocket.send(r)}async _startSocket(e,t){const n=this,r=n.engine,s=r.Generator,a=Date.now(),i=new URL(r.serviceURL);let c=Object.assign({},r.headers||{});c.q=a,c.c=Streams.isAvailable,Object.entries(c||{}).forEach((e=>{i.searchParams.append(e[0],encodeURIComponent(e[1]))})),n.webSocket=new WebSocket(i.toString(),["ws4is"]),n.webSocket.binaryType="arraybuffer";const o=n.onCall.bind(n);n.webSocket.onopen=i=>{if(n.emit("online",i),s.on("call",o),!r.isWSAPI)return e(!0);s.once("api",(async n=>{try{n.challenge=a,await r.registerAPI(n),e(!0)}catch(e){t(e)}}))},n.webSocket.onclose=e=>{s.off("call",o),n.stop(),n.emit("offline",e)},n.webSocket.onerror=e=>{s.off("call",o),t(e),n.stop(),n.emit("error",e)},n.webSocket.onmessage=e=>{n._prepareMessage(e.data)}}_isJsonObj(e){return e.startsWith("{")&&e.endsWith("}")}_isJsonArray(e){return e.startsWith("[")&&e.endsWith("]")}async _prepareMessage(e){const t=this,n=t.engine.Generator;let r=null,s=e;try{e instanceof ArrayBuffer&&(s=await Streams.decompress(e));const a=s.trim();t._isJsonObj(a)||t._isJsonArray(a)?(r=JSON.parse(s),t.onMessage(r)):n.emit("raw",s)}catch(e){n.emit("error",e)}}async onMessage(e){const t=this;let n=null;const r=t.engine,s=r.Generator,a=r.Security;if("api"===e.cmd)return s.emit("api",e.data);if("err"===e.cmd)return s.emit("error",e.result);if("enc"===e.cmd){if(!Security.isAvailable)return s.emit("error",new Error("Security available on https/wss only"));n=await a.decrypt(e)}"data"===e.cmd&&(n=e.data),n?t.queue.process(n).forEach((e=>t.emit("message",e))):t.emit("message",n)}}
const ERROR_MESSAGE="Invalid definition for Engine Remote Service",ERROR_API_UNDEFIEND="API Url not defined!",ERROR_SVC_UNDEFIEND="Service Url not defined!";class Engine{constructor(e){if(!(e=e||{}).api)throw new Error(ERROR_API_UNDEFIEND);if(!e.service)throw new Error(ERROR_SVC_UNDEFIEND);const n=this;if(n.cfg=null,n.isWSAPI=!1,n.isWebChannel=!1,n.isSockChannel=!1,n.Security=null,n.Generator=null,n.WebChannel=null,n.SocketChannel=null,n.cfg=e,n.isWSAPI=e.api===e.service&&0==e.api.indexOf("ws"),n.headers=e.headers||{},n.isWebChannel=0===e.service.indexOf("http"),n.isSockChannel=0===e.service.indexOf("ws"),!1===(n.isWebChannel||n.isSockChannel))throw new Error(ERROR_MESSAGE)}async init(){const e=this;e.isActive||(e.Security=new Security,e.Generator=new Generator,(e.isWebChannel||0==e.isWSAPI)&&(e.WebChannel=new WebChannel,await e.WebChannel.init(e)),e.isSockChannel&&(e.SocketChannel=new SocketChannel,await e.SocketChannel.init(e)))}async registerAPI(e){const n=this;e.signature&&(n.Security.isActive||await n.Security.init(e)),n.Generator.build(e.api)}stop(){const e=this;e.WebChannel&&e.WebChannel.stop(),e.SocketChannel&&e.SocketChannel.stop(),e.Generator&&e.Generator.stop(),e.WebChannel=null,e.SocketChannel=null,e.Generator=null,e.Security=null,e.cfg=null}get api(){return this.Generator?this.Generator.api:null}get isActive(){const e=this;return!(e.SocketChannel&&!e.SocketChannel.isOpen||!e.api||!e.Security)}get apiURL(){return this.cfg?this.cfg.api:null}get serviceURL(){return this.cfg?this.cfg.service:null}static async init(e){const n=new Engine(e);return await n.init(),n}}