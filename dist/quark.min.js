/* Quark Engine v1.0.1 (c) Green Screens Ltd. */
class Events{constructor(){this.listeners=new Map,this.onceListeners=new Map,this.triggerdLabels=new Map}_fCheckPast(label,callback){return!!this.triggerdLabels.has(label)&&(callback(this.triggerdLabels.get(label)),!0)}on(label,callback,checkPast=!1){this.listeners.has(label)||this.listeners.set(label,[]),this.listeners.get(label).push(callback),checkPast&&this._fCheckPast(label,callback)}onReady(label,callback){this.on(label,callback,!0)}once(label,callback,checkPast=!1){this.onceListeners.has(label)||this.onceListeners.set(label,[]),checkPast&&this._fCheckPast(label,callback)||this.onceListeners.get(label).push(callback)}onceReady(label,callback){this.once(label,callback,!0)}off(label,callback=!0){if(!0===callback)this.listeners.delete(label),this.onceListeners.delete(label);else{let _off=inListener=>{let listeners=inListener.get(label);listeners&&inListener.set(label,listeners.filter(value=>!(value===callback)))};_off(this.listeners),_off(this.onceListeners)}}emit(label,...args){let res=!1;this.triggerdLabels.set(label,...args);let _trigger=(inListener,label,...args)=>{let listeners=inListener.get(label);listeners&&listeners.length&&(listeners.forEach(listener=>{listener(...args)}),res=!0)};return _trigger(this.onceListeners,label,...args),_trigger(this.listeners,label,...args),this.onceListeners.delete(label),res}}class Queue extends Map{constructor(){super();this.up=0,this.down=0,this.tid=0}updateRequest(req,callback){this.tid++,this.up++,req.tid=this.tid.toString(),this.set(req.tid,callback)}reset(){let me=this;me.up>50&&me.down>=me.up&&(me.up=0,me.down=0)}process(obj){let me=this;Array.isArray(obj)?obj.forEach(me.execute.bind(me)):me.execute(obj)}execute(obj){let me=this,tid=obj.tid;if(me.down++,me.has(tid))try{me.get(tid)(null,obj)}finally{me.delete(tid)}me.reset()}}function hex2ab(str){let a=[];for(let i=0;i<str.length;i+=2)a.push(parseInt("0x"+str.substr(i,2),16));return a}function str2ab(str){let buf=new ArrayBuffer(str.length),bufView=new Uint8Array(buf);for(let i=0,strLen=str.length;i<strLen;i++)bufView[i]=str.charCodeAt(i);return buf}function buf2hex(buffer){return Array.prototype.map.call(new Uint8Array(buffer),x=>("00"+x.toString(16)).slice(-2)).join("")}function stringFromUTF8Array(data){let extraByteMap=[1,1,1,1,2,2,3,0],count=data.length,str="";for(let index=0;index<count;){let ch=data[index++];if(128&ch){let extra=extraByteMap[ch>>3&7];if(!(64&ch)||!extra||index+extra>count)return null;for(ch&=63>>extra;extra>0;extra-=1){let chx=data[index++];if(128!=(192&chx))return null;ch=ch<<6|63&chx}}str+=String.fromCharCode(ch)}return str}class Streams{static isAvailable(){return"undefined"!=typeof CompressionStream}static async compress(text,encoding="gzip"){let byteArray=(new TextEncoder).encode(text),cs=new CompressionStream(encoding),writer=cs.writable.getWriter();return writer.write(byteArray),writer.close(),new Response(cs.readable).arrayBuffer()}static async decompress(byteArray,encoding="gzip"){let cs=new DecompressionStream(encoding),writer=cs.writable.getWriter();writer.write(byteArray),writer.close();let arrayBuffer=await new Response(cs.readable).arrayBuffer();return(new TextDecoder).decode(arrayBuffer)}}class Security{constructor(){let me=this;me.VERSION=0,me.encKEY=null,me.aesKEY=null,me.exportedAES=null,me.encoder=new TextEncoder,me.decoder=new TextDecoder}getChallenge(cfg){return[cfg.challenge||"",cfg.keyEnc||"",cfg.keyVer||""].join("")}getRandom(size){let array=new Uint8Array(size);return window.crypto.getRandomValues(array),array}async generateAesKey(){return window.crypto.subtle.generateKey({name:"AES-CTR",length:128},!0,["encrypt","decrypt"])}async exportAesKey(key){let buffer=await window.crypto.subtle.exportKey("raw",key);return new Uint8Array(buffer)}async importRsaKey(key,type,mode){let binaryDer=str2ab(window.atob(key));return window.crypto.subtle.importKey("spki",binaryDer,type,!0,[mode])}async verify(key,signature,challenge){let binSignature=str2ab(atob(signature)),binChallenge=this.encoder.encode(challenge);return window.crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-384"}},key,binSignature,binChallenge)}async encryptRSA(data){let me=this,encoded=data;return"string"==typeof data&&(encoded=me.encoder.encode(data)),window.crypto.subtle.encrypt("RSA-OAEP",me.encKEY,encoded)}async encryptAesMessage(key,iv,data){let encoded=this.encoder.encode(data),type={name:"AES-CTR",counter:iv,length:128};return window.crypto.subtle.encrypt(type,key,encoded)}async decryptAesMessage(key,iv,data){let databin=hex2ab(data),ivbin=hex2ab(iv),counter=new Uint8Array(ivbin),dataArray=new Uint8Array(databin),type={name:"AES-CTR",counter,length:128};return window.crypto.subtle.decrypt(type,key,dataArray)}get isValid(){return null!==this.encKEY&&null!==this.aesKEY}get isAvailable(){return null!=window.crypto.subtle}async init(cfg){let me=this;if(!me.isAvailable)return void console.log("Security mode not available, TLS protocol required.");console.log("Security Initializing..."),me.VERSION++,me.encKEY=await importRsaKey(cfg.keyEnc,{name:"RSA-OAEP",hash:"SHA-256"},"encrypt"),me.aesKEY=await generateAesKey(),me.exportedAES=await exportAesKey(aesKEY);let verKey=await importRsaKey(cfg.keyVer,{name:"ECDSA",namedCurve:"P-384"},"verify");if(!await verify(verKey,cfg.signature,getChallenge(cfg||{})))throw me.encKEY=null,me.aesKEY=null,me.exportedAES=null,new Error("Signature invalid");console.log("Security Initialized!")}async encrypt(data,bin){let iv=getRandom(16),key=new Uint8Array(iv.length+this.exportedAES.length);key.set(iv),key.set(this.exportedAES,iv.length);let encryptedKey=await encryptRSA(key),encryptedData=await encryptAesMessage(this.aesKEY,iv,data);return!0===bin?{d:encryptedData,k:encryptedKey}:{d:buf2hex(encryptedData),k:buf2hex(encryptedKey)}}async decrypt(cfg){let iv=cfg.iv,data=cfg.d,message=await decryptAesMessage(this.aesKEY,iv,data),str=this.decoder.decode(message),obj=JSON.parse(str);return obj&&"ws"==obj.type&&"data"===obj.cmd&&(obj=obj.data),obj}}class Generator extends Events{constructor(){super(),this._model={}}get api(){return this._model}stop(){this.off("call"),this.off("api")}build(o){let data=o?o.api||o:null;return data?(this._buildAPI(data),data):data}_buildAPI(cfg){let me=this;Array.isArray(cfg)?cfg.every(v=>(me._buildInstance(v),!0)):me._buildInstance(cfg)}_buildInstance(api){let me=this,tree=null,action=null;tree=me._buildNamespace(api.namespace),tree[api.action]||(tree[api.action]={}),action=tree[api.action],api.methods.every(v=>(me._buildMethod(api.namespace,api.action,action,v),!0))}_buildNamespace(namespace){let me=this,tmp=null;return namespace.split(".").every(v=>(tmp?(tmp[v]||(tmp[v]={}),tmp=tmp[v]):(me._model[v]||(me._model[v]={}),tmp=me._model[v]),!0)),tmp}_buildMethod(namespace,action,instance,api){let enc=!1!==api.encrypt,cfg={n:namespace,c:action,m:api.name,l:api.len,e:enc};instance[api.name]=this._apiFn(cfg)}_apiFn(params){var me=this,prop=params;return function fn(){let args,req,promise=null;return args=Array.prototype.slice.call(arguments),req={namespace:prop.n,action:prop.c,method:prop.m,e:prop.e,data:args},promise=new Promise((resolve,reject)=>{me.emit("call",req,(err,obj)=>{me._onResponse(err,obj,prop,resolve,reject)})}),promise}}_onResponse(err,obj,prop,response,reject){if(err)return void reject(err);prop.c===obj.action&&prop.m===obj.method&&obj.result&&obj.result.success?response(obj.result):reject(obj.result||obj)}}class WebChannel{async init(engine){let me=this,Generator=engine.Generator,data=(engine.Security,await me.getAPI(engine.apiURL));await engine.registerAPI(data),engine.isSockChannel||Generator.on("call",async(req,callback)=>{let o=null,e=null;try{o=await me.onCall(engine,req)}catch(err){e=err}callback(e,o)})}stop(){}async getAPI(url){let service=url,id=Date.now(),resp=await fetch(service,{method:"get",headers:{"x-time":id}}),data=await resp.json();return data.challenge=id.toString(),data}async fetchCall(url,data){let MIME="application/json",req={method:"post",heaedrs:{Accept:MIME,"Content-Type":MIME},body:JSON.stringify(data)},res=await fetch(url,req);return await res.json()}async onCall(engine,req){let Security=engine.Security,url=engine.serviceURL,hasArgs=Array.isArray(req.data)&&req.data.length>0,data=req;if(Security.isActive()&&hasArgs&&(data=await Security.encrypt(JSON.stringify(req))),data=await this.fetchCall(url,data),"err"==data.cmd)throw new Error(data.result.msg);return"enc"===data.cmd&&(data=await Security.decrypt(data)),data}}class SocketChannel{constructor(){this.queue=new Queue,this.webSocket=null,this.engine=null}async init(engine){let me=this;return me.stop(),me.engine=engine,new Promise((resolve,reject)=>(me._startSocket(resolve,reject),null))}stop(){return null!=this.webSocket&&(this.webSocket.close(),this.webSocket=null,this.engine=null,!0)}async _startSocket(resolve,reject){let me=this,engine=me.engine,generator=engine.Generator,challenge=(engine.Security,Date.now()),url=engine.serviceURL+"?q="+challenge;me.webSocket=new WebSocket(url,["ws4is"]),me.webSocket.binaryType="arraybuffer";let onCall=me.onCall.bind(me);me.webSocket.onopen=event=>{if(generator.on("call",onCall),!engine.isWSAPI)return resolve(!0);generator.once("api",async data=>{try{data.challenge=challenge,await engine.registerAPI(data),resolve(!0)}catch(e){reject(e)}})},me.webSocket.onclose=event=>{generator.off("call",onCall),me.stop()},me.webSocket.onerror=event=>{generator.off("call",onCall),reject(event),me.stop()},me.webSocket.onmessage=event=>{me._prepareMessage(event.data)}}async _prepareMessage(message){let me=this,obj=null,generator=me.engine.Generator;try{if(message instanceof ArrayBuffer){let text=await Streams.decompress(message);obj=JSON.parse(text)}"string"==typeof message&&(obj=JSON.parse(message)),obj?me.onMessage(obj):generator.emit("error",event)}catch(e){generator.emit("error",e)}}async onMessage(obj){let me=this,data=null,engine=me.engine,generator=engine.Generator,security=engine.Security;return"api"===obj.cmd?generator.emit("api",obj.data):"err"===obj.cmd?generator.emit("error",obj.result):("enc"===obj.cmd&&(data=await security.decrypt(obj)),"data"===obj.cmd&&(data=obj.data),void(data&&me.queue.process(data)))}}const ERROR_MESSAGE="Invalid definition for Engine Remote Service",ERROR_API_UNDEFIEND="API Url not defined!",ERROR_SVC_UNDEFIEND="Service Url not defined!";class Engine{constructor(cfg){if(!(cfg=cfg||{}).api)throw new Error(ERROR_API_UNDEFIEND);if(!cfg.service)throw new Error(ERROR_SVC_UNDEFIEND);let me=this;if(me.cfg=null,me.isWSAPI=!1,me.isWebChannel=!1,me.isSockChannel=!1,me.Security=null,me.Generator=null,me.WebChannel=null,me.SockChannel=null,me.cfg=cfg,me.isWSAPI=cfg.api===cfg.service&&0==cfg.api.indexOf("ws"),me.isWebChannel=0===cfg.service.indexOf("http"),me.isSockChannel=0===cfg.service.indexOf("ws"),!1===(me.isWebChannel||me.isSockChannel))throw new Error(ERROR_MESSAGE)}async init(){let me=this;me.isActive||(me.Security=new Security,me.Generator=new Generator,me.isWebChannel&&(me.WebChannel=new WebChannel,await me.WebChannel.init(me)),me.isSockChannel&&(me.SocketChannel=new SocketChannel,await me.SocketChannel.init(me)))}async registerAPI(data){let me=this;data.signature&&(me.Security.isActive()||await me.Security.init(data)),me.Generator.build(data.api)}stop(){let me=this;me.WebChannel&&me.WebChannel.stop(),me.SocketChannel&&me.SocketChannel.stop(),me.Generator&&me.Generator.stop(),me.WebChannel=null,me.SocketChannel=null,me.Generator=null,me.Security=null,me.cfg=null}get api(){return this.Generator?this.Generator.api:null}get isActive(){return this.api&&this.Security}get apiURL(){return this.cfg?this.cfg.api:null}get serviceURL(){return this.cfg?this.cfg.service:null}}