/* Quark Engine v2.3.0 (c) Green Screens Ltd. */
class Events{constructor(){this.listeners=new Map,this.onceListeners=new Map,this.triggers=new Map}_checkPast(label,callback){const me=this;return!!me.triggers.has(label)&&(callback(me.triggers.get(label)),!0)}on(label,callback,checkPast=!1){this.listeners.has(label)||this.listeners.set(label,[]),this.listeners.get(label).push(callback),checkPast&&this._checkPast(label,callback)}onReady(label,callback){this.on(label,callback,!0)}once(label,callback,checkPast=!1){const me=this;me.onceListeners.has(label)||me.onceListeners.set(label,[]),checkPast&&me._checkPast(label,callback)||me.onceListeners.get(label).push(callback)}onceReady(label,callback){this.once(label,callback,!0)}off(label,callback=!0){const me=this;if(!0===callback)me.removeAllListeners(label);else{const _off=inListener=>{const listeners=inListener.get(label);listeners&&inListener.set(label,listeners.filter(value=>value!==callback))};_off(me.listeners),_off(me.onceListeners)}}removeAllListeners(label){this.listeners.delete(label),this.onceListeners.delete(label)}trigger(label,...args){this.emit(label,...args)}emit(label,...args){this.triggers.set(label,...args);const _trigger=(inListener,label,...args)=>{const listeners=inListener.get(label);if(listeners&&listeners.length)return listeners.forEach(listener=>{listener(...args)}),!0};let res=_trigger(this.onceListeners,label,...args);return res=res||_trigger(this.listeners,label,...args),this.onceListeners.delete(label),res}}class Buffer{static from(value,type){switch(type){case"base64":return Buffer.fromBase64(value);case"hex":return Buffer.fromHex(value)}return value}static to(value,type){switch(type){case"base64":return Buffer.toBase64(value);case"hex":return Buffer.toHex(value)}return value}static fromHex(value){const arry=[];for(let i=0;i<value.length;i+=2)arry.push(parseInt("0x"+value.substr(i,2),16));return new Uint8Array(arry)}static fromBase64(value){const strbin=atob(value),buffer=new ArrayBuffer(strbin.length),bufView=new Uint8Array(buffer);for(let i=0,strLen=strbin.length;i<strLen;i++)bufView[i]=strbin.charCodeAt(i);return bufView}static toHex(buffer){return Array.prototype.map.call(new Uint8Array(buffer),x=>("00"+x.toString(16)).slice(-2)).join("")}static toBase64(buffer){return btoa(new Uint8Array(buffer))}}class Queue extends Map{constructor(){super();this.up=0,this.down=0,this.tid=0}updateRequest(req,callback){this.tid++,this.up++,req.tid=this.tid.toString(),this.set(req.tid,callback)}reset(){const me=this;me.up>50&&me.down>=me.up&&(me.up=0,me.down=0)}process(obj){const me=this,unknown=[];if(Array.isArray(obj))obj.forEach(o=>{const res=me.execute(o);res&&unkown.push(res)});else{const o=me.execute(obj);o&&unknown.push(o)}return unknown}execute(obj){const me=this,tid=obj.tid;let unknown=null;if(me.down++,me.has(tid))try{me.get(tid)(null,obj)}catch(e){console.log(e),me.get(tid)(e,null)}finally{me.delete(tid)}else unknown=obj;return me.reset(),unknown}}class Streams{static get isAvailable(){return"undefined"!=typeof CompressionStream&&"undefined"!=typeof DecompressionStream}static async compress(text,encoding="gzip"){const byteArray=(new TextEncoder).encode(text),cs=new CompressionStream(encoding),writer=cs.writable.getWriter();return writer.write(byteArray),writer.close(),new Response(cs.readable).arrayBuffer()}static async decompress(byteArray,encoding="gzip"){const cs=new DecompressionStream(encoding),writer=cs.writable.getWriter();writer.write(byteArray),writer.close();const arrayBuffer=await new Response(cs.readable).arrayBuffer();return(new TextDecoder).decode(arrayBuffer)}}class Security{constructor(){const me=this;me.VERSION=0,me.encKEY=null,me.aesKEY=null,me.exportedAES=null,me.encoder=new TextEncoder,me.decoder=new TextDecoder}getChallenge(cfg){return[cfg.challenge||"",cfg.keyEnc||"",cfg.keyVer||""].join("")}getRandom(size){const array=new Uint8Array(size);return crypto.getRandomValues(array),array}async generateAesKey(){return crypto.subtle.generateKey({name:"AES-CTR",length:128},!0,["encrypt","decrypt"])}async exportAesKey(key){const buffer=await crypto.subtle.exportKey("raw",key);return new Uint8Array(buffer)}async importRsaKey(key,type,mode){const binaryDer=Buffer.from(key,"base64");return crypto.subtle.importKey("spki",binaryDer,type,!0,[mode])}async verify(key,signature,challenge){const binSignature=Buffer.from(signature,"base64"),binChallenge=this.encoder.encode(challenge);return crypto.subtle.verify({name:"ECDSA",hash:{name:"SHA-384"}},key,binSignature,binChallenge)}async encryptRSA(data){const me=this;let encoded=data;return"string"==typeof data&&(encoded=me.encoder.encode(data)),crypto.subtle.encrypt("RSA-OAEP",me.encKEY,encoded)}async encryptAesMessage(key,iv,data){const encoded=this.encoder.encode(data),type={name:"AES-CTR",counter:iv,length:128};return crypto.subtle.encrypt(type,key,encoded)}async decryptAesMessage(key,iv,data){const databin=Buffer.from(data,"hex"),type={name:"AES-CTR",counter:Buffer.from(iv,"hex"),length:128};return crypto.subtle.decrypt(type,key,databin)}get isValid(){return null!==this.encKEY&&null!==this.aesKEY}static get isAvailable(){return null!=crypto.subtle}async init(cfg){const me=this;if(!Security.isAvailable)return void console.log("Security mode not available, TLS protocol required.");console.log("Security Initializing..."),me.VERSION++,me.encKEY=await me.importRsaKey(cfg.keyEnc,{name:"RSA-OAEP",hash:"SHA-256"},"encrypt"),me.aesKEY=await me.generateAesKey(),me.exportedAES=await me.exportAesKey(me.aesKEY);const verKey=await me.importRsaKey(cfg.keyVer,{name:"ECDSA",namedCurve:"P-384"},"verify");if(!await me.verify(verKey,cfg.signature,me.getChallenge(cfg||{})))throw me.encKEY=null,me.aesKEY=null,me.exportedAES=null,new Error("Signature invalid");console.log("Security Initialized!")}async encrypt(data,bin){const me=this,iv=me.getRandom(16),key=new Uint8Array(iv.length+me.exportedAES.length);key.set(iv),key.set(me.exportedAES,iv.length);const str="string"==typeof data?data:JSON.stringify(data),encryptedKey=await me.encryptRSA(key),encryptedData=await me.encryptAesMessage(me.aesKEY,iv,str);return!0===bin?{t:"1",d:encryptedData,k:encryptedKey}:{t:"1",d:Buffer.to(encryptedData,"hex"),k:Buffer.to(encryptedKey,"hex")}}async decrypt(cfg){const iv=cfg.iv,data=cfg.d,message=await this.decryptAesMessage(this.aesKEY,iv,data),str=this.decoder.decode(message),obj=JSON.parse(str);return obj&&"ws"==obj.type&&"data"===obj.cmd?obj.data:obj}static async init(cfg){const security=new Security;return await security.init(cfg),security}}class Generator extends Events{constructor(id){super(),this._model={},this.id=id}get api(){return this._model}stop(){this.removeAllListeners("call"),this.removeAllListeners("api"),this.detach()}_cleanup(obj,id){for(let k in obj){let el=obj[k];"object"==typeof el?this._cleanup(el,id)&&(obj[k]=null):el._id_===id&&(obj[k]=null)}return 0===Object.values(obj).filter(o=>null!=o).length}detach(){this._cleanup(this._model,this.id),this._model={}}attach(){}build(o){const data=o?o.api||o:null;return data?(this._buildAPI(data),this.attach(),data):data}_buildAPI(cfg){const me=this;Array.isArray(cfg)?cfg.forEach(v=>me._buildInstance(v)):me._buildInstance(cfg)}_buildInstance(api){const me=this;let tree=null,action=null;tree=me._buildNamespace(api.namespace),tree[api.action]||(tree[api.action]={}),action=tree[api.action],api.methods.forEach(v=>me._buildMethod(api.namespace,api.action,action,v,me.id))}_buildNamespace(namespace){let tmp=globalThis,tmp2=this._model;return namespace.split(".").every(v=>(tmp[v]||(tmp[v]={}),tmp=tmp[v],tmp2[v]||(tmp2[v]=tmp),tmp2=tmp,!0)),tmp}_buildMethod(namespace,action,instance,api,id){const enc=!1!==api.encrypt,cfg={n:namespace,c:action,m:api.name,l:api.len,e:enc,i:id};instance[api.name]=this._apiFn(cfg),instance[api.name]._id_=id}_apiFn(params){const me=this,prop=params;return function fn(){const args=Array.prototype.slice.call(arguments),req={namespace:prop.n,action:prop.c,method:prop.m,id:prop.i,e:prop.e,data:args,ts:Date.now()},promise=new Promise((resolve,reject)=>{me.emit("call",req,(err,obj)=>{me._onResponse(err,obj,prop,resolve,reject)})});return promise}}_onResponse(err,obj,prop,response,reject){if(err)return void reject(err);prop.c===obj.action&&prop.m===obj.method&&obj.result&&obj.result.success?response(obj.result):reject(obj.result||obj)}static async build(cfg){const generator=new Generator;return generator.build(cfg),generator}}class WebChannel{async init(engine){const me=this;me.engine&&me.stop(),me.engine=engine;const generator=engine.Generator,data=await me.getAPI(engine.apiURL);await engine.registerAPI(data),engine.isSockChannel||generator.on("call",me.onRequest.bind(me))}stop(){const engine=this.engine;this.engine=null,engine.Generator.off("call"),engine.isSockChannel||fetch(engine.serviceURL,{method:"delete"})}async onRequest(req,callback){const me=this;let o=null,e=null;if(req.id===me.engine.id){try{o=await me.onCall(me.engine,req)}catch(err){e=err}callback(e,o)}}async getAPI(url){const service=url,engine=this.engine,id=Date.now(),headers=Object.assign({},engine.headers||{},{"x-time":id}),resp=await fetch(service,{method:"get",headers,credentials:"same-origin"}),data=await resp.json();return data.challenge=id.toString(),data}async fetchCall(url,data){const engine=this.engine,MIME="application/json",HEADERS_={Accept:MIME,"Content-Type":MIME},service=new URL(url),headers=Object.assign({},engine.headers||{},HEADERS_),querys=Object.assign({},engine.querys||{}),payload=Object.assign({},engine.querys||{},data||{}),req={method:"post",headers,body:JSON.stringify(payload)};Object.entries(querys||{}).forEach(v=>{service.searchParams.append(v[0],encodeURIComponent(v[1]))});const res=await fetch(service.toString(),req);return await res.json()}async onCall(engine,req){const security=engine.Security,url=engine.serviceURL,hasArgs=Array.isArray(req.data)&&req.data.length>0;let data=req;if(security.isValid&&hasArgs&&(data=await security.encrypt(req)),data=await this.fetchCall(url,data),"err"==data.cmd)throw new Error(data.result.msg);if("enc"===data.cmd){if(!security.isValid)throw new Error("Security available on https/wss only");data=await security.decrypt(data)}return data}}class SocketChannel extends Events{constructor(){super();this.queue=new Queue,this.webSocket=null,this.engine=null}async init(engine){const me=this;return me.stop(),me.engine=engine,new Promise((resolve,reject)=>(me._startSocket(resolve,reject),null))}get isOpen(){return null!=this.webSocket&&this.webSocket.readyState===this.webSocket.OPEN}stop(){return null!=this.webSocket&&(this.webSocket.close(),this.webSocket=null,this.engine=null,!0)}canEncrypt(req){const hasArgs=Array.isArray(req.data)&&req.data.length>0&&!1!==req.e;return this.engine.Security.isValid&&hasArgs}async onCall(req,callback){const me=this;let msg=null;if(req.id!==me.engine.id)return;const isEncrypt=me.canEncrypt(req);if(me.queue.updateRequest(req,callback),isEncrypt){const enc=await me.engine.Security.encrypt(req.data),payload=Object.assign({},me.engine.querys||{},enc||{});req.data=[payload]}const data={cmd:isEncrypt?"enc":"data",type:"ws",data:[req]};if(msg=JSON.stringify(data),!Streams.isAvailable)return me.webSocket.send(msg);msg=await Streams.compress(msg),me.webSocket.send(msg)}async _startSocket(resolve,reject){const me=this,engine=me.engine,generator=engine.Generator,challenge=Date.now(),url=new URL(engine.serviceURL),querys=(Object.assign({},engine.headers||{}),Object.assign({},engine.querys||{}));querys.q=challenge,querys.c=Streams.isAvailable,Object.entries(querys||{}).forEach(v=>{url.searchParams.append(v[0],encodeURIComponent(v[1]))}),me.webSocket=new WebSocket(url.toString(),["ws4is"]),me.webSocket.binaryType="arraybuffer";const onCall=me.onCall.bind(me);me.webSocket.onopen=event=>{if(me.emit("online",event),generator.on("call",onCall),!engine.isWSAPI)return resolve(!0);generator.once("api",async data=>{try{data.challenge=challenge,await engine.registerAPI(data),resolve(!0)}catch(e){reject(e)}})},me.webSocket.onclose=event=>{generator.off("call",onCall),me.stop(),me.emit("offline",event)},me.webSocket.onerror=event=>{generator.off("call",onCall),reject(event),me.stop(),me.emit("error",event)},me.webSocket.onmessage=event=>{me._prepareMessage(event.data)}}_isJsonObj(msg){return msg.startsWith("{")&&msg.endsWith("}")}_isJsonArray(msg){return msg.startsWith("[")&&msg.endsWith("]")}async _prepareMessage(message){const me=this,generator=me.engine.Generator;let obj=null,text=message;try{message instanceof ArrayBuffer&&(text=await Streams.decompress(message));const msg=text.trim();me._isJsonObj(msg)||me._isJsonArray(msg)?(obj=JSON.parse(text),me.onMessage(obj)):generator.emit("raw",text)}catch(e){generator.emit("error",e)}}async onMessage(obj){const me=this;let data=null;const engine=me.engine,generator=engine.Generator,security=engine.Security;if("api"===obj.cmd)return generator.emit("api",obj.data);if("err"===obj.cmd)return generator.emit("error",obj.result);if("enc"===obj.cmd){if(!Security.isAvailable)return generator.emit("error",new Error("Security available on https/wss only"));data=await security.decrypt(obj)}if("data"===obj.cmd&&(data=obj.data),data){me.queue.process(data).forEach(obj=>me.emit("message",obj))}else me.emit("message",data)}}const ERROR_MESSAGE="Invalid definition for Engine Remote Service",ERROR_API_UNDEFIEND="API Url not defined!",ERROR_SVC_UNDEFIEND="Service Url not defined!";class Engine{constructor(cfg){if(!(cfg=cfg||{}).api)throw new Error(ERROR_API_UNDEFIEND);if(!cfg.service)throw new Error(ERROR_SVC_UNDEFIEND);const me=this;if(me.cfg=null,me.isWSAPI=!1,me.isWebChannel=!1,me.isSockChannel=!1,me.Security=null,me.Generator=null,me.WebChannel=null,me.SocketChannel=null,me.id=Date.now(),me.cfg=cfg,me.isWSAPI=cfg.api===cfg.service&&0==cfg.api.indexOf("ws"),me.headers=cfg.headers||{},me.querys=cfg.querys||{},me.isWebChannel=0===cfg.service.indexOf("http"),me.isSockChannel=0===cfg.service.indexOf("ws"),!1===(me.isWebChannel||me.isSockChannel))throw new Error(ERROR_MESSAGE)}async init(){const me=this;me.isActive||(me.Security=new Security,me.Generator=new Generator(me.id),(me.isWebChannel||0==me.isWSAPI)&&(me.WebChannel=new WebChannel,await me.WebChannel.init(me)),me.isSockChannel&&(me.SocketChannel=new SocketChannel,await me.SocketChannel.init(me)))}async registerAPI(data){const me=this;data.signature&&(me.Security.isActive||await me.Security.init(data)),me.Generator.build(data.api)}stop(){const me=this;me.WebChannel&&me.WebChannel.stop(),me.SocketChannel&&me.SocketChannel.stop(),me.Generator&&me.Generator.stop(),me.WebChannel=null,me.SocketChannel=null,me.Generator=null,me.Security=null,me.cfg=null}get api(){return this.Generator?this.Generator.api:null}get isActive(){return!(this.SocketChannel&&!this.SocketChannel.isOpen)&&!(!this.api||!this.Security)}get apiURL(){return this.cfg?this.cfg.api:null}get serviceURL(){return this.cfg?this.cfg.service:null}static async init(cfg){const engine=new Engine(cfg);return await engine.init(),engine}}