class QuarkBuffer{static#e=new TextEncoder;static#t=new TextDecoder;static validateData(e){let t=null;if(e instanceof Array)t=new Uint8Array(e);else if(e instanceof ArrayQuarkBuffer)t=new Uint8Array(e);else if(e instanceof Uint8Array)t=e;else if(e instanceof String||'string'==typeof e)t=QuarkBuffer.fromText(e);else{if(!e.toArrayQuarkBuffer)throw'Invalid input, must be String or ArrayQuarkBuffer or Uint8Array';t=new Uint8Array(e.toArrayQuarkBuffer())}return t}static isString(e){return'string'==typeof e}static isHexString(e){return!!QuarkBuffer.isString(e)&&/^[0-9A-Fa-f]+$/g.test(e)}static toQuarkBuffer(e,t=!1){const r=QuarkBuffer;return r.isString(e)&&(e=t?r.fromBase64(e):r.isHexString(e)?r.fromHex(e):r.fromText(e)),r.validateData(e)}static toText(e){return QuarkBuffer.isText(e)?e:QuarkBuffer.#t.decode(e)}static fromText(e){return QuarkBuffer.isText(e)?QuarkBuffer.#e.encode(e):e}static isText(e){return'string'==typeof e}static fromHex(e){const t=[];for(let r=0;r<e.length;r+=2)t.push(parseInt('0x'+e.substr(r,2),16));return new Uint8Array(t)}static toHex(e){return Array.prototype.map.call(new Uint8Array(e),(e=>('00'+e.toString(16)).slice(-2))).join('')}static fromBase64(e){const t=atob(e),r=new ArrayQuarkBuffer(t.length),n=new Uint8Array(r);for(let e=0,r=t.length;e<r;e++)n[e]=t.charCodeAt(e);return n}static toBase64(e){return globalThis.btoa(new Uint8Array(e))}}class QuarkEvent extends EventTarget{#r=new Set;#n(e='',t){const r=Array.from(this.#r);return QuarkEvent.#i(t)?r.filter((r=>r.type===e&&r.listener===t)):r.filter((t=>t.type===e))}addEventListener(e,t,r){return!!QuarkEvent.#i(t)&&(this.#r.add({type:e,listener:t}),super.addEventListener(e,t,r))}removeEventListener(e,t){const r=this,n=r.#n(e,t);n.forEach((e=>super.removeEventListener(e.type,e.listener))),n.forEach((e=>r.#r.delete(e)))}unbind(){Array.from(this.#r).forEach((e=>{super.removeEventListener(e.type,e.listener)})),this.#r.clear()}on(e='',t){return this.addEventListener(e,t)}once(e,t){let wrap=e=>{t(e),wrap=null};return wrap.type=e,wrap.listener=t,this.addEventListener(e,wrap,{once:!0})}off(e='',t){return this.removeEventListener(e,t)}emit(e,t){if(!e)return!1;const r=new CustomEvent(e,{detail:t});return this.dispatchEvent(r)}send(e,t){this.emit(e,t)}listen(e,t){this.on(e,t)}unlisten(e,t){this.off(e,t)}wait(t=''){if(!t)return e('Event undefined!');const r=this;return new Promise(((e,n)=>{r.once(t,(t=>e(t)))}))}static#i(e){return'function'==typeof e}static prevent(e){QuarkEvent.#i(e,'preventDefault')&&e.preventDefault(),QuarkEvent.#i(e,'stopPropagation')&&e.stopPropagation()}static{Object.freeze(Event)}}class Streams{static get isAvailable(){return'undefined'!=typeof CompressionStream&&'undefined'!=typeof DecompressionStream}static#a(e,t=!1,r=!1){if(!e instanceof Uint8Array)return e;const n=Streams.#s(t,r),i=new Uint8Array(8+e.length),a=new DataView(i.QuarkBuffer);return a.setUint8(0,71),a.setUint8(1,83),a.setUint8(2,5),a.setUint8(3,n),a.setUint32(4,e.length),i.set(e,8),i}static async wrap(e,t){return e=Streams.toBinary(e),e=await Streams.compressOrDefault(e),e=await t.encrypt(e),e=Streams.#a(e,t.isValid,Streams.isAvailable)}static async unwrap(e,t){e instanceof Uint8Array&&(e=e.QuarkBuffer);const r=new DataView(e),n=Streams.#c(r);if(e=Streams.toBinary(e),!n)return e;const i=r.getUint8(3),a=r.getUint32(4);if(r.byteLength!==a+8)return e;e=e.slice(8);const s=Streams.isCompressFlag(i);if(Streams.isEncryptFlag(i)&&(e=await(t?.decrypt(e))),s&&(e=await Streams.decompress(e).arrayQuarkBuffer()),e=Streams.toBinary(e),!Streams.isJson(e))throw new Error('Invalid response');return JSON.parse(QuarkBuffer.toText(e))}static#c(e){return e.byteLength>8&&18259===e.getUint16(0)&&5===e.getUint8(2)}static isCompressFlag(e){return 1==(1&e)}static isEncryptFlag(e){return 2==(2&e)}static#s(e,t){return(t?1:0)|(e?2:0)}static#o(e,t){const r=this.toBinary(e),n=t.writable.getWriter();return n.write(r),n.close(),new Response(t.readable)}static async compressOrDefault(e,t='gzip'){if(!Streams.isAvailable)return e;const r=await Streams.compress(e,t).arrayQuarkBuffer();return Streams.toBinary(r)}static async decompressOrDefault(e,t='gzip'){if(!Streams.isAvailable)return e;const r=await Streams.decompress(e,t).arrayQuarkBuffer();return Streams.toBinary(r)}static compress(e,t='gzip'){const r=new CompressionStream(t);return this.#o(e,r)}static decompress(e,t='gzip'){const r=new DecompressionStream(t);return this.#o(e,r)}static toBinary(e){return e instanceof Uint8Array?e:e instanceof ArrayQuarkBuffer?new Uint8Array(e):'string'==typeof e?QuarkBuffer.fromText(e):this.toBinary(JSON.stringify(e))}static isCompressed(e){const t=this;return e=t.toBinary(e),t.isGzip(e)||t.isZlib(e)}static isGzip(e){return 31===e.at(0)&&139===e.at(1)&&8===e.at(2)}static isZlib(e){return 120===e.at(0)&&[1,94,156,218].indexOf(e.at(1))>-1}static isJson(e){const t=this,r=(e='string'==typeof e?e.trim():t.toBinary(e)).at(0),n=e.at(e.length-1);return t.#u(r,n)||t.#l(r,n)}static#l(e,t){return!('{'!==e&&123!==e||'}'!==t&&125!==t)}static#u(e,t){return!('['!==e&&91!==e||']'!==t&&93!==t)}}class Security{static#f={name:'ECDH',namedCurve:'P-256'};static#y={name:'AES-CTR',length:256};#h=null;#p=null;#d=null;static getRandom(e){const t=new Uint8Array(e);return crypto.getRandomValues(t),t}static initKeyPair(){return crypto.subtle.generateKey(Security.#f,!0,['deriveKey','deriveBits'])}static async importKey(e,t,r){const n=QuarkBuffer.fromBase64(e),i=r?r.split(','):[];return crypto.subtle.importKey('spki',n,t,!0,i)}static async exportKey(e){const t=await crypto.subtle.exportKey('raw',e);return QuarkBuffer.toHex(t)}static async verify(e,t,r){t=QuarkBuffer.fromBase64(t),r=QuarkBuffer.toQuarkBuffer(r);return crypto.subtle.verify({name:'ECDSA',hash:{name:'SHA-384'}},e,t,r)}get publicKey(){return this.#h}cookie(e='/'){return`gs-public-key=${this.#h||''};path=${e}`}updateCookie(e='/'){document.cookie=this.cookie(e)}#g(e){return[e.challenge||'',e.keyEnc||'',e.keyVer||''].join('')}async#m(e){const t=await Security.importKey(e.keyVer,{name:'ECDSA',namedCurve:'P-384'},'verify');if(!await Security.verify(t,e.signature,this.#g(e)))throw new Error('Signature invalid')}#S(e){return Security.importKey(e.keyEnc,Security.#f,'')}#w(e,t){const r={name:'ECDH',public:t},n=Security.#y;return crypto.subtle.deriveKey(r,e,n,!1,['encrypt','decrypt'])}#b(e){e=QuarkBuffer.toQuarkBuffer(e);const t=Object.assign({counter:e},Security.#y);return t.length=128,t}async encryptRaw(e,t,r){const n=QuarkBuffer.toQuarkBuffer(r),i=this.#b(t);return crypto.subtle.encrypt(i,e,n)}async decryptRaw(e,t,r){const n=QuarkBuffer.toQuarkBuffer(r),i=this.#b(t);return crypto.subtle.decrypt(i,e,n)}async decryptAsQuarkBuffer(e,t,r){const n=await this.decryptRaw(e,t,r);return QuarkBuffer.toQuarkBuffer(n)}async encryptAsQuarkBuffer(e,t,r){const n=await this.encryptRaw(e,t,r);return QuarkBuffer.toQuarkBuffer(n)}async decryptAsString(e,t,r){const n=await this.decryptRaw(e,t,r);return QuarkBuffer.toText(n)}async encryptAsHex(e,t,r){const n=await this.encryptRaw(e,t,r);return QuarkBuffer.toHex(n)}get isValid(){return null!==this.#h&&null!==this.#d}static get isAvailable(){return!!crypto.subtle}async init(e){if(!Security.isAvailable)return;const t=this;await t.#m(e);const r=await t.#S(e);t.#d=await t.#w(t.#p.privateKey,r),t.#p=null}async encrypt(e){const t=this;if(!t.isValid)return e;if(!e instanceof Uint8Array)return e;const r=Security.getRandom(16),n=await t.encryptAsQuarkBuffer(t.#d,r,e),i=new Uint8Array(r.length+n.length);return i.set(r,0),i.set(n,r.length),i}async decrypt(e,t){return t||(t=e.slice(0,16),e=e.slice(16)),await this.decryptAsQuarkBuffer(this.#d,t,e)}async#k(){const e=this;return e.#h||(e.#p=await Security.initKeyPair(),e.#h=await Security.exportKey(e.#p.publicKey)),e.#h}static async create(e){const t=new Security;return await t.#k(),e&&await t.init(e),t}}class Queue extends Map{#A=0;#E=0;#C=0;updateRequest(e){const t=this;t.#C++,t.#A++,e.tid=t.#C.toString(),t.set(e.tid,e)}reset(){const e=this;e.#A>50&&e.#E>=e.#A&&(e.#A=0,e.#E=0,e.clear())}process(e){const t=this,r=[];if(Array.isArray(e))e.forEach((e=>{const r=t.execute(e);r&&unkown.push(r)}));else{const n=t.execute(e);n&&r.push(n)}return r}execute(e){const t=this,r=e.tid;let n=null;if(t.#E++,t.has(r)){const n=t.get(r);try{n.finish(e)}catch(e){n.finish(e)}finally{t.delete(r)}}else n=e;return t.reset(),n}}class Request{#v=0;#B=0;#Q;constructor(e,t){const r=this;r.#Q=t,r.#B=e,r.#P()}get(e,t){const r=this;return'timeout'===t?r.timeout:'finish'===t?r.callback.bind(r):e[t]}callback(e){const t=this;if(!t.timeout)return t.#I(),t.#Q(e)}get timeout(){return!0===this.#B}#I(){0!==this.#v&&clearTimeout(this.#v)}#P(){const e=this;0!==e.#B&&(e.#v=setTimeout((()=>{e.#B=!0,e.#Q(new Error('Call timeouted!'))}),e.#B))}static wrap(e,t,r){return new Proxy(e,new Request(t,r))}}class Generator extends QuarkEvent{#x={};#v=null;#R=0;#B=0;constructor(e=0,t=0){super(),this.#v=e,this.#B=t}get api(){return this.#x}stop(){const e=this;e.off('call'),e.off('api'),e.off('raw'),e.off('error'),e.#U()}#O(e,t){for(let r in e){let n=e[r];'object'==typeof n?this.#O(n,t)&&(e[r]=null):n._id_===t&&(e[r]=null)}return 0===Object.values(e).filter((e=>null!=e)).length}#U(){const e=this;e.#O(e.#x,e.#v),e.#x={}}build(e){const t=e?e.api||e:null;return t&&this.#W(t),t}#W(e){const t=this;Array.isArray(e)?e.forEach((e=>t.#T(e))):t.#T(e)}#T(e){const t=this;let r=null,n=null;r=t.#K(e.namespace),r[e.action]||(r[e.action]={}),n=r[e.action],t.#M(e.methods)?.forEach((r=>t.#G(e.namespace,e.action,n,r,t.#v)))}#M(e){return e.reduce(((e,t,r,n)=>{if(1==e.filter((e=>e.name==t.name)).length)return e;const i=n.filter((e=>e.name==t.name));if(1===i.length)return e.push(t),e;const a=i.filter((e=>e.name===t.name)).reduce(((e,t)=>(e.len.push(t.len),e.async[t.len]=t.async,e)),{name:t.name,len:[],async:{}});return e.push(a),e}),[])}#K(e){let t=globalThis,r=this.#x;return e.split('.').every((e=>(t[e]||(t[e]={}),t=t[e],r[e]||(r[e]=t),r=t,!0))),t}#G(e,t,r,n,i){const a=!1!==n.encrypt,s={n:e,c:t,m:n.name,l:n.len,a:n.async,e:a,i};r[n.name]=this.#D(s),r[n.name]._id_=i}#D(e){const t=this,r=e;return function(){const e=Array.prototype.slice.call(arguments),n=Array.isArray(r.l),i=n?r.l.filter((t=>t===e.length)).pop():r.l;if(e.length!=i)throw new Error(`Invalid arguments length. Required (${r.l})`);const a=n?r.a[e.length]:r.a,s=a?0:t.#B,c={namespace:r.n,action:r.c,method:r.m,id:r.i,enc:r.e,data:e,key:++t.#R,tid:0,ts:Date.now()};return Object.seal(c),new Promise(((e,r)=>{try{const n=Request.wrap(c,s,(n=>{t.#q(n,e,r)}));t.emit('call',n)}catch(e){r(e)}}))}}#q(e,t,r){if(e instanceof Error)return r(e);const n=e.result||e;n.success?t(n):r(n)}static build(e,t,r){const n=new Generator(t,r);return n.build(e),n}}class SocketChannel extends QuarkEvent{#J=new Queue;#j=null;#L=null;#_=0;async init(e){const t=this;return t.stop(),t.#L=e,new Promise(((e,r)=>(t.#N(e,r),null)))}get isOpen(){const e=this;return null!=e.#j&&e.#j.readyState===e.#j.OPEN}stop(){const e=this;return null!=e.#j&&(e.#j.close(),e.#j=null,e.#L=null,!0)}#H(e,t){const r={type:'GS',cmd:e,data:t?[t]:null};return JSON.stringify(r)}get#F(){return this.#H('ping')}async#V(e){const t=this;if((e=e.detail).id!==t.#L.id)return;t.#J.updateRequest(e);const r=t.#H('data',e),n=await Streams.wrap(r,t.#L.Security);t.#j.send(n)}async#N(e,t){const r=this,n=r.#L,i=n.Generator,a=Date.now(),s=new URL(n.serviceURL),c=Object.assign({},n.querys||{});c.q=a,c.c=Streams.isAvailable,Object.entries(c||{}).forEach((e=>{e[1]&&s.searchParams.append(e[0],encodeURIComponent(e[1]))})),n.Security.updateCookie(),r.#j=new WebSocket(s.toString(),['quark']),r.#j.binaryType='arraybuffer';const o=r.#V.bind(r);r.#j.onopen=s=>{if(r.emit('online',s),i.on('call',o),r.#Y(),!n.isWSAPI)return e(!0);i.once('api',(async r=>{try{const t=r.detail;t.challenge=a,await n.registerAPI(t),e(!0)}catch(r){t(r)}}))},r.#j.onclose=e=>{i.off('call',o),clearInterval(r.#_),r.stop(),r.emit('offline',e)},r.#j.onerror=e=>{i.off('call',o),t(e),r.stop(),r.emit('error',e)},r.#j.onmessage=async e=>{try{e.data instanceof ArrayBuffer?await r.#z(e.data):await r.#$(e.data)}catch(t){t.data=e,i.emit('error',t)}}}#Y(){const e=this;e.#_=setInterval((()=>{e.send(e.#F)}),15e3)}async#z(e){const t=this,r=t.#L.Security;e=await Streams.unwrap(e,r);if(!Streams.isJson(e))return generator.emit('raw',e);Array.isArray(e)?e.forEach((e=>t.#Z(e))):t.#Z(e)}async#$(e){const t=this,r=t.#L.Generator;try{if(!Streams.isJson(e))return r.emit('raw',e);e=JSON.parse(e),Array.isArray(e)?e.forEach((e=>t.#Z(e))):t.#Z(e)}catch(e){r.emit('error',e)}}async#Z(e){const t=this;let r=null;const n=t.#L.Generator;if('api'===e.cmd)return n.emit('api',e.data);if('err'===e.cmd)return n.emit('error',e.result);if('data'===e.cmd&&(r=e.data),r){t.#J.process(r).forEach((e=>t.emit('message',e)))}else t.emit('message',r)}}class WebChannel{static#X='application/octet-stream';static#ee='application/json';#L=null;async init(e){const t=this;t.#L&&t.stop(),t.#L=e;const r=e.Generator,n=await t.#te(e.apiURL);await e.registerAPI(n),e.isSocketChannel||r.on('call',t.#re.bind(t))}stop(){const e=this.#L;if(this.#L=null,e.Generator.off('call'),!e.isSocketChannel)try{fetch(e.serviceURL,{method:'delete'})}catch(e){}}async#re(e){const t=this;let r=null;if((e=e.detail).id===t.#L.id)try{r=await t.#V(t.#L,e),e.finish(r)}catch(t){e.finish(t)}}async#te(e){const t=e,r=this.#L,n=Date.now(),i=Object.assign({},r.headers||{},{'x-time':n}),a=await fetch(t,{method:'get',headers:i,credentials:'same-origin'}),s=await a.json();return s.challenge=n.toString(),s}get#ne(){return`${WebChannel.#X}, ${WebChannel.#ee}`}#ie(e){return'string'!=typeof e?WebChannel.#X:WebChannel.#ee}async#ae(e,t,r,n){const i=this,a=i.#L,s=i.#ie(t),c={Accept:i.#ne,'Content-Type':s,'Accept-Encoding':'gzip,deflate,br'};n&&Streams.isAvailable&&(t=Streams.toBinary(t),t=await Streams.compressOrDefault(t),c['Content-Encoding']='gzip');const o=new URL(e),u=Object.assign({},a.headers||{},c,r||{}),l=Object.assign({},a.querys||{}),f={method:'post',headers:u,body:t};return Object.entries(l||{}).forEach((e=>{o.searchParams.append(e[0],encodeURIComponent(e[1]))})),await fetch(o.toString(),f)}async#q(e){const t=e.headers.get('content-type')||'',r=t.includes(WebChannel.#X),n=t.includes(WebChannel.#ee),i=!r&&!n;if(n)return await e.json();if(i){const t=await e.text();if(!Streams.isJson(t))throw new Error('Invalid response');return JSON.parse(t)}const a=await e.arrayBuffer(),s=await Streams.unwrap(a,this.#L.Security);return s&&'ws'==s.type&&'data'===s.cmd?s.data:s}async#V(e,t){const r=this,n=e.Security,i=e.serviceURL,a=n?.isValid;let s=!1,c=null;a?c=await Streams.wrap(t,r.#L.Security):(c=JSON.stringify(c),s=!0);const o={};a&&(o['gs-public-key']=n.publicKey);const u=await r.#ae(i,c,o,s),l=await r.#q(u);if('err'==l.cmd)throw new Error(l.result.msg);return l}}class QuarkEngine{#se=null;#ce=!1;#oe=!1;#ue=!1;#le=null;#fe=null;#ye=null;#he=null;#pe=null;#de=null;#v=null;constructor(e){if(!(e=e||{}).api)throw new Error('API Url not defined!');if(!e.service)throw new Error('Service Url not defined!');const t=this;if(t.#se=null,t.#ce=!1,t.#oe=!1,t.#ue=!1,t.#le=null,t.#fe=null,t.#ye=null,t.#he=null,t.#v=Date.now(),t.#se=e,t.#ce=e.api===e.service&&0==e.api.indexOf('ws'),t.#pe=e.headers||{},t.#de=e.querys||{},t.#oe=0===e.service.indexOf('http'),t.#ue=0===e.service.indexOf('ws'),!1===(t.isWebChannel||t.isSocketChannel))throw new Error('Invalid definition for Engine Remote Service')}async init(){const e=this;if(!e.isActive)return e.#le=await Security.create(),e.#fe=new Generator(e.id),(e.isWebChannel||0==e.isWSAPI)&&(e.#ye=new WebChannel,await e.WebChannel.init(e)),e.isSocketChannel&&(e.#he=new SocketChannel,await e.SocketChannel.init(e)),e}async registerAPI(e){const t=this;e.signature&&await(t.Security?.init(e)),t.Generator?.build(e.api)}stop(){const e=this;e.WebChannel?.stop(),e.SocketChannel?.stop(),e.Generator?.stop(),e.#ye=null,e.#he=null,e.#fe=null,e.#le=null,e.#se=null}get api(){return this.Generator?.api||null}get isActive(){const e=this;return!(e.SocketChannel&&!e.SocketChannel.isOpen)&&!(!e.api||!e.Security)}get apiURL(){return this.cfg?.api||null}get serviceURL(){return this.cfg?.service||null}get cfg(){return this.#se}get isWSAPI(){return this.#ce}get isWebChannel(){return this.#oe}get isSocketChannel(){return this.#ue}get Security(){return this.#le}get Generator(){return this.#fe}get WebChannel(){return this.#ye}get SocketChannel(){return this.#he}get headers(){return this.#pe}get querys(){return this.#de}get id(){return this.#v}static async init(e){return new QuarkEngine(e).init()}}export{Generator,QuarkBuffer,QuarkEngine,QuarkEvent,Queue,Request,Security,SocketChannel,Streams,WebChannel};
//# sourceMappingURL=io.greenscreens.quark.esm.min.js.map
