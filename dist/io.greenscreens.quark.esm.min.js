class QuarkBuffer{static#e=new TextEncoder;static#t=new TextDecoder;static validateData(e){let t=null;if(e instanceof Array)t=new Uint8Array(e);else if(e instanceof ArrayBuffer)t=new Uint8Array(e);else if(e instanceof Uint8Array)t=e;else if(e instanceof String||'string'==typeof e)t=QuarkBuffer.fromText(e);else{if(!e.toArrayBuffer)throw'Invalid input, must be String or ArrayBuffer or Uint8Array';t=new Uint8Array(e.toArrayBuffer())}return t}static isString(e){return'string'==typeof e}static isHexString(e){return!!QuarkBuffer.isString(e)&&/^[0-9A-Fa-f]+$/g.test(e)}static toBuffer(e,t=!1){const r=QuarkBuffer;return r.isString(e)&&(e=t?r.fromBase64(e):r.isHexString(e)?r.fromHex(e):r.fromText(e)),r.validateData(e)}static toText(e){return QuarkBuffer.isText(e)?e:QuarkBuffer.#t.decode(e)}static fromText(e){return QuarkBuffer.isText(e)?QuarkBuffer.#e.encode(e):e}static isText(e){return'string'==typeof e}static fromHex(e){const t=[];for(let r=0;r<e.length;r+=2)t.push(parseInt('0x'+e.substr(r,2),16));return new Uint8Array(t)}static toHex(e){return Array.prototype.map.call(new Uint8Array(e),(e=>('00'+e.toString(16)).slice(-2))).join('')}static fromBase64(e){const t=atob(e),r=new ArrayBuffer(t.length),n=new Uint8Array(r);for(let e=0,r=t.length;e<r;e++)n[e]=t.charCodeAt(e);return n}static toBase64(e){return e=QuarkBuffer.toBuffer(e),btoa(e.reduce(((e,t)=>e+String.fromCharCode(t)),''))}}class QuarkEvent extends EventTarget{#r=new Set;#n(e='',t){const r=Array.from(this.#r);return QuarkEvent.#a(t)?r.filter((r=>r.type===e&&r.listener===t)):r.filter((t=>t.type===e))}addEventListener(e,t,r){return!!QuarkEvent.#a(t)&&(this.#r.add({type:e,listener:t}),super.addEventListener(e,t,r))}removeEventListener(e,t){const r=this,n=r.#n(e,t);n.forEach((e=>super.removeEventListener(e.type,e.listener))),n.forEach((e=>r.#r.delete(e)))}unbind(){Array.from(this.#r).forEach((e=>{super.removeEventListener(e.type,e.listener)})),this.#r.clear()}on(e='',t){return this.addEventListener(e,t)}once(e,t){let wrap=e=>{t(e),wrap=null};return wrap.type=e,wrap.listener=t,this.addEventListener(e,wrap,{once:!0})}off(e='',t){return this.removeEventListener(e,t)}emit(e,t){if(!e)return!1;const r=new CustomEvent(e,{detail:t});return this.dispatchEvent(r)}send(e,t){this.emit(e,t)}listen(e,t){this.on(e,t)}unlisten(e,t){this.off(e,t)}wait(t=''){if(!t)return e('Event undefined!');const r=this;return new Promise(((e,n)=>{r.once(t,(t=>e(t)))}))}static#a(e){return'function'==typeof e}static prevent(e){QuarkEvent.#a(e,'preventDefault')&&e.preventDefault(),QuarkEvent.#a(e,'stopPropagation')&&e.stopPropagation()}static{Object.freeze(QuarkEvent)}}class QuarkStreams{static get isAvailable(){return'undefined'!=typeof CompressionStream&&'undefined'!=typeof DecompressionStream}static#i(e,t=!1,r=!1){if(!e instanceof Uint8Array)return e;const n=QuarkStreams.#s(t,r),a=new Uint8Array(8+e.length),i=new DataView(a.buffer);return i.setUint8(0,71),i.setUint8(1,83),i.setUint8(2,5),i.setUint8(3,n),i.setUint32(4,e.length),a.set(e,8),a}static async wrap(e,t){return e=QuarkStreams.toBinary(e),e=await QuarkStreams.compressOrDefault(e),e=await t.encrypt(e),e=QuarkStreams.#i(e,t.isValid,QuarkStreams.isAvailable)}static async unwrap(e,t,r){e instanceof Uint8Array&&(e=e.buffer);const n=new DataView(e),a=QuarkStreams.#c(n);if(e=Streams.toBinary(e),!a)return e;const i=n.getUint8(3),s=n.getUint32(4);if(n.byteLength!==s+8)return e;e=e.slice(8);const c=QuarkStreams.isCompressFlag(i),u=QuarkStreams.isEncryptFlag(i);let o=null;if(QuarkStreams.isApiFlag(i)){const a=n.getUint32(8),i=n.getUint32(12+a),s=n.getUint32(12+a+4+i);o={challenge:r,keyEnc:e.slice(4,4+a),keyVer:e.slice(4+a+4,4+a+4+i),signature:e.slice(4+a+4+i+4,4+a+4+i+4+s)},await t.init(o),e=e.slice(12+a+i+s)}if(u&&(e=await(t?.decrypt(e))),c&&(e=await QuarkStreams.decompress(e).arrayBuffer()),e=QuarkStreams.toBinary(e),!QuarkStreams.isJson(e))throw new Error('Invalid response');return JSON.parse(QuarkBuffer.toText(e))}static#c(e){return e.byteLength>8&&18259===e.getUint16(0)&&5===e.getUint8(2)}static isCompressFlag(e){return 1==(1&e)}static isEncryptFlag(e){return 2==(2&e)}static isApiFlag(e){return 4==(4&e)}static#s(e,t){return(t?1:0)|(e?2:0)}static#u(e,t){const r=this.toBinary(e),n=t.writable.getWriter();return n.write(r),n.close(),new Response(t.readable)}static async compressOrDefault(e,t='gzip'){if(!QuarkStreams.isAvailable)return e;const r=await QuarkStreams.compress(e,t).arrayBuffer();return Streams.toBinary(r)}static async decompressOrDefault(e,t='gzip'){if(!QuarkStreams.isAvailable)return e;const r=await QuarkStreams.decompress(e,t).arrayBuffer();return QuarkStreams.toBinary(r)}static compress(e,t='gzip'){const r=new CompressionStream(t);return this.#u(e,r)}static decompress(e,t='gzip'){const r=new DecompressionStream(t);return this.#u(e,r)}static toBinary(e){return e instanceof Uint8Array?e:e instanceof ArrayBuffer?new Uint8Array(e):'string'==typeof e?QuarkBuffer.fromText(e):this.toBinary(JSON.stringify(e))}static isCompressed(e){return e=this.toBinary(e),this.isGzip(e)}static isGzip(e){return 31===e.at(0)&&139===e.at(1)&&8===e.at(2)}static isZlib(e){return 120===e.at(0)&&[1,94,156,218].indexOf(e.at(1))>-1}static isJson(e){const t=this,r=(e='string'==typeof e?e.trim():t.toBinary(e)).at(0),n=e.at(e.length-1);return t.#o(r,n)||t.#l(r,n)}static#l(e,t){return!('{'!==e&&123!==e||'}'!==t&&125!==t)}static#o(e,t){return!('['!==e&&91!==e||']'!==t&&93!==t)}}class QuarkSecurity{static#f={name:'ECDH',namedCurve:'P-256'};static#y={name:'ECDSA',namedCurve:'P-384'};static#h={name:'ECDSA',hash:'SHA-384'};static#p={name:'AES-CTR',length:256};#d=null;#g=null;#k=null;static getRandom(e){const t=new Uint8Array(e);return crypto.getRandomValues(t),t}static initKeyPair(){return crypto.subtle.generateKey(Security.#f,!0,['deriveKey','deriveBits'])}static async importKey(e,t,r){const n=QuarkBuffer.toBuffer(e,!0),a=r?r.split(','):[];return crypto.subtle.importKey('spki',n,t,!0,a)}static async exportKey(e){const t=await crypto.subtle.exportKey('raw',e);return QuarkBuffer.toHex(t)}static async verify(e,t,r){t=QuarkBuffer.toBuffer(t,!0),r=QuarkBuffer.toBuffer(r);const n=QuarkSecurity.#h;return crypto.subtle.verify(n,e,t,r)}static async sign(e,t){return t=QuarkBuffer.toBuffer(t),crypto.subtle.sign('ECDSA',e,t)}get publicKey(){return this.#d}cookie(e='/'){return`gs-public-key=${this.#d||''};path=${e}`}updateCookie(e='/'){document.cookie=this.cookie(e)}#m(e){return[e.challenge||'',this.#S(e.keyEnc)||'',this.#S(e.keyVer)||''].join('')}#S(e){return QuarkBuffer.isText(e)?e:QuarkBuffer.toBase64(e)}async#w(e){const t=QuarkSecurity.#y,r=await QuarkSecurity.importKey(e.keyVer,t,'verify');if(!await QuarkSecurity.verify(r,e.signature,this.#m(e)))throw new Error('Signature invalid')}#b(e){return QuarkSecurity.importKey(e.keyEnc,QuarkSecurity.#f,'')}#Q(e,t){const r={name:'ECDH',public:t},n=QuarkSecurity.#p;return crypto.subtle.deriveKey(r,e,n,!1,['encrypt','decrypt'])}#A(e){e=QuarkBuffer.toBuffer(e);const t=Object.assign({counter:e},QuarkSecurity.#p);return t.length=128,t}async encryptRaw(e,t,r){const n=QuarkBuffer.toBuffer(r),a=this.#A(t);return crypto.subtle.encrypt(a,e,n)}async decryptRaw(e,t,r){const n=QuarkBuffer.toBuffer(r),a=this.#A(t);return crypto.subtle.decrypt(a,e,n)}async decryptAsBuffer(e,t,r){const n=await this.decryptRaw(e,t,r);return QuarkBuffer.toBuffer(n)}async encryptAsBuffer(e,t,r){const n=await this.encryptRaw(e,t,r);return QuarkBuffer.toBuffer(n)}async decryptAsString(e,t,r){const n=await this.decryptRaw(e,t,r);return QuarkBuffer.toText(n)}async encryptAsHex(e,t,r){const n=await this.encryptRaw(e,t,r);return QuarkBuffer.toHex(n)}get isValid(){return null!==this.#d&&null!==this.#k}static get isAvailable(){return!!crypto.subtle}async init(e){if(!QuarkSecurity.isAvailable)return;const t=this;await t.#w(e);const r=await t.#b(e);t.#k=await t.#Q(t.#g.privateKey,r),t.#g=null}async encrypt(e){const t=this;if(!t.isValid)return e;if(!e instanceof Uint8Array)return e;const r=QuarkSecurity.getRandom(16),n=await t.encryptAsBuffer(t.#k,r,e),a=new Uint8Array(r.length+n.length);return a.set(r,0),a.set(n,r.length),a}async decrypt(e,t){return t||(t=e.slice(0,16),e=e.slice(16)),await this.decryptAsBuffer(this.#k,t,e)}async#E(){const e=this;e.#g=await QuarkSecurity.initKeyPair(),e.#d=await QuarkSecurity.exportKey(e.#g.publicKey)}static async create(e){const t=new QuarkSecurity;return await t.#E(),e&&await t.init(e),t}}class QuarkQueue extends Map{#C=0;#B=0;#v=0;updateRequest(e){const t=this;t.#v++,t.#C++,e.tid=t.#v.toString(),t.set(e.tid,e)}reset(){const e=this;e.#C>50&&e.#B>=e.#C&&(e.#C=0,e.#B=0,e.clear())}process(e){const t=this,r=[];if(Array.isArray(e))e.forEach((e=>{const r=t.execute(e);r&&unkown.push(r)}));else{const n=t.execute(e);n&&r.push(n)}return r}execute(e){const t=this,r=e.tid;let n=null;if(t.#B++,t.has(r)){const n=t.get(r);try{n.finish(e)}catch(e){n.finish(e)}finally{t.delete(r)}}else n=e;return t.reset(),n}}class QuarkRequest{#x=0;#P=0;#R;constructor(e,t){const r=this;r.#R=t,r.#P=e,r.#I()}get(e,t){const r=this;return'timeout'===t?r.timeout:'finish'===t?r.callback.bind(r):e[t]}callback(e){const t=this;if(!t.timeout)return t.#U(),t.#R(e)}get timeout(){return!0===this.#P}#U(){0!==this.#x&&clearTimeout(this.#x)}#I(){const e=this;0!==e.#P&&(e.#x=setTimeout((()=>{e.#P=!0,e.#R(new Error('Call timeouted!'))}),e.#P))}static wrap(e,t,r){return new Proxy(e,new QuarkRequest(t,r))}}class QuarkGenerator extends QuarkEvent{#W={};#x=null;#T=0;#P=0;constructor(e=0,t=0){super(),this.#x=e,this.#P=t}get api(){return this.#W}stop(){const e=this;e.off('call'),e.off('api'),e.off('raw'),e.off('error'),e.#O()}#K(e,t){for(let r in e){let n=e[r];'object'==typeof n?this.#K(n,t)&&(e[r]=null):n._id_===t&&(e[r]=null)}return 0===Object.values(e).filter((e=>null!=e)).length}#O(){const e=this;e.#K(e.#W,e.#x),e.#W={}}build(e){const t=e?e.api||e:null;return t&&this.#M(t),t}#M(e){const t=this;Array.isArray(e)?e.forEach((e=>t.#D(e))):t.#D(e)}#D(e){const t=this;let r=null,n=null;r=t.#G(e.namespace),r[e.action]||(r[e.action]={}),n=r[e.action],t.#q(e.methods)?.forEach((e=>t.#_(n,e,t.#x)))}#q(e){return e.reduce(((e,t,r,n)=>{if(1==e.filter((e=>e.name==t.name)).length)return e;const a=n.filter((e=>e.name==t.name));if(1===a.length)return e.push(t),e;const i=a.filter((e=>e.name===t.name)).reduce(((e,t)=>(e.mid.push(t.mid),e.len.push(t.len),e.async[t.len]=t.async,e)),{name:t.name,mid:[],len:[],async:{}});return e.push(i),e}),[])}#G(e){let t=globalThis,r=this.#W;return e.split('.').every((e=>(t[e]||(t[e]={}),t=t[e],r[e]||(r[e]=t),r=t,!0))),t}#_(e,t,r){const n=!1!==t.encrypt,a={l:t.len,a:t.async||!1,x:t.mid,e:n,i:r};e[t.name]=this.#L(a),e[t.name]._id_=r}#L(e){const t=this,r=e;return function(){const e=Array.prototype.slice.call(arguments),n=Array.isArray(r.l),a=n?r.l.filter((t=>t===e.length)).pop():r.l;if(e.length!=a)throw new Error(`Invalid arguments length. Required (${r.l})`);const i=Array.isArray(r.x)?r.x[a-1]:r.x,s=n?r.a[e.length]:r.a,c=s?0:t.#P,u={handle:i,id:r.i,enc:r.e,data:e,key:++t.#T,tid:0,ts:Date.now()};return Object.seal(u),new Promise(((e,r)=>{try{const n=QuarkRequest.wrap(u,c,(n=>{t.#j(n,e,r)}));t.emit('call',n)}catch(e){r(e)}}))}}#j(e,t,r){if(e instanceof Error)return r(e);const n=e.result||e;n.success?t(n):r(n)}static build(e,t,r){const n=new QuarkGenerator(t,r);return n.build(e),n}}class QuarkSocketChannel extends QuarkEvent{#J=Date.now();#F=new QuarkQueue;#N=null;#V=null;#H=0;async init(e){const t=this;return t.stop(),t.#V=e,new Promise(((e,r)=>(t.#Y(e,r),null)))}get isOpen(){const e=this;return null!=e.#N&&e.#N.readyState===e.#N.OPEN}stop(){const e=this;return null!=e.#N&&(e.#N.close(),e.#N=null,e.#V=null,!0)}#z(e,t){const r={type:'GS',cmd:e,data:t?[t]:null};return JSON.stringify(r)}get#$(){return this.#z('ping')}async#Z(e){const t=this;if((e=e.detail).id!==t.#V.id)return;t.#F.updateRequest(e);const r=t.#z('data',e),n=await QuarkStreams.wrap(r,t.#V.Security);t.#N.send(n)}async#Y(e,t){const r=this,n=r.#V,a=n.Generator,i=new URL(n.serviceURL),s=Object.assign({},n.querys||{});s.q=r.#J,s.c=QuarkStreams.isAvailable,Object.entries(s||{}).forEach((e=>{e[1]&&i.searchParams.append(e[0],encodeURIComponent(e[1]))})),n.Security.updateCookie(),r.#N=new WebSocket(i.toString(),['quark']),r.#N.binaryType='arraybuffer';const c=r.#Z.bind(r);r.#N.onopen=i=>{if(r.emit('online',i),a.on('call',c),r.#X(),!n.isWSAPI)return e(!0);a.once('api',(async a=>{try{const t=a.detail;t.challenge=r.#J,await n.registerAPI(t),e(!0)}catch(a){t(a)}}))},r.#N.onclose=e=>{a.off('call',c),clearInterval(r.#H),r.stop(),r.emit('offline',e)},r.#N.onerror=e=>{a.off('call',c),t(e),r.stop(),r.emit('error',e)},r.#N.onmessage=async e=>{try{e.data instanceof ArrayBuffer?await r.#ee(e.data):await r.#te(e.data)}catch(t){t.data=e,a.emit('error',t)}}}#X(){const e=this;e.#H=setInterval((()=>{e.send(e.#$)}),15e3)}async#ee(e){const t=this,r=t.#V.Security;e=await QuarkStreams.unwrap(e,r,t.#J);if(!QuarkStreams.isJson(e))return generator.emit('raw',e);Array.isArray(e)?e.forEach((e=>t.#re(e))):t.#re(e)}async#te(e){const t=this,r=t.#V.Generator;try{if(!QuarkStreams.isJson(e))return r.emit('raw',e);e=JSON.parse(e),Array.isArray(e)?e.forEach((e=>t.#re(e))):t.#re(e)}catch(e){r.emit('error',e)}}async#re(e){const t=this;let r=null;const n=t.#V.Generator;if('api'===e.cmd)return n.emit('api',e.data);if('err'===e.cmd)return n.emit('error',e.result);if('data'===e.cmd&&(r=e.data),r){t.#F.process(r).forEach((e=>t.emit('message',e)))}else t.emit('message',r)}}class QuarkWebChannel{static#ne='application/octet-stream';static#ae='application/json';#V=null;async init(e){const t=this;t.#V&&t.stop(),t.#V=e;const r=e.Generator,n=await t.#ie(e.apiURL);await e.registerAPI(n),e.isSocketChannel||r.on('call',t.#se.bind(t))}stop(){const e=this.#V;if(this.#V=null,e.Generator.off('call'),!e.isSocketChannel)try{fetch(e.serviceURL,{method:'delete'})}catch(e){}}async#se(e){const t=this;let r=null;if((e=e.detail).id===t.#V.id)try{r=await t.#Z(t.#V,e),e.finish(r)}catch(t){e.finish(t)}}async#ie(e){const t=this,r=t.#V,n=r.Security,a=Date.now(),i=Object.assign({},r.headers||{},{'gs-challenge':a});n.publicKey&&(i['gs-public-key']=n.publicKey);const s=await t.#ce(e,null,i,!1,'get'),c=await t.#j(s,a);return c.challenge=a.toString(),c}get#ue(){return`${QuarkWebChannel.#ne}, ${QuarkWebChannel.#ae}`}#oe(e){return'string'!=typeof e?QuarkWebChannel.#ne:QuarkWebChannel.#ae}async#ce(e,t,r,n,a='post'){const i=this,s=i.#V,c=i.#oe(t),u={Accept:i.#ue,'Content-Type':c,'Accept-Encoding':'gzip,deflate,br'};n&&QuarkStreams.isAvailable&&(t=QuarkStreams.toBinary(t),t=await QuarkStreams.compressOrDefault(t),u['Content-Encoding']='gzip');const o=new URL(e),l=Object.assign({},s.headers||{},u,r||{}),f=Object.assign({},s.querys||{}),y={method:a,headers:l};return t&&(y.body=t),Object.entries(f||{}).forEach((e=>{o.searchParams.append(e[0],encodeURIComponent(e[1]))})),await fetch(o.toString(),y)}async#j(e,t){let r=await QuarkWebChannel.fromResponse(e);return r instanceof Uint8Array&&(r=await QuarkStreams.unwrap(r,this.#V.Security,t)),r&&'ws'==r.type&&'data'===r.cmd?r.data:r}async#Z(e,t){const r=this,n=e.Security,a=e.serviceURL,i=n?.isValid;let s=!1,c=null;t&&(i?c=await QuarkStreams.wrap(t,r.#V.Security):(c=JSON.stringify(c),s=!0));const u={};i&&(u['gs-public-key']=n.publicKey);const o=await r.#ce(a,c,u,s),l=await r.#j(o);if('err'==l.cmd)throw new Error(l.result.msg);return l}static async fromResponse(e){if(!e.ok)throw new Error(`${e.status} : ${e.statusText}`);const t=e.headers.get('content-type')||'',r=t.includes(QuarkWebChannel.#ne),n=t.includes(QuarkWebChannel.#ae),a=!r&&!n;if(n)return await e.json();if(a)return await e.text();const i=await e.arrayBuffer();return new Uint8Array(i)}}class QuarkEngine{#le=null;#fe=!1;#ye=!1;#he=!1;#pe=null;#de=null;#ge=null;#ke=null;#me=null;#Se=null;#x=null;constructor(e){if(!(e=e||{}).api)throw new Error('API Url not defined!');if(!e.service)throw new Error('Service Url not defined!');const t=this;if(t.#le=null,t.#fe=!1,t.#ye=!1,t.#he=!1,t.#pe=null,t.#de=null,t.#ge=null,t.#ke=null,t.#x=Date.now(),t.#le=e,t.#fe=e.api===e.service&&0==e.api.indexOf('ws'),t.#me=e.headers||{},t.#Se=e.querys||{},t.#pe=e.security instanceof QuarkSecurity?e.security:null,t.#ye=0===e.service.indexOf('http'),t.#he=0===e.service.indexOf('ws'),!1===(t.isWebChannel||t.isSocketChannel))throw new Error('Invalid definition for Engine Remote Service')}async init(){const e=this;if(!e.isActive)return e.#pe||(e.#pe=await QuarkSecurity.create()),e.#de=new QuarkGenerator(e.id),(e.isWebChannel||0==e.isWSAPI)&&(e.#ge=new QuarkWebChannel,await e.WebChannel.init(e)),e.isSocketChannel&&(e.#ke=new QuarkSocketChannel,await e.SocketChannel.init(e)),e}async registerAPI(e){const t=this;e.signature&&!t.Security?.isValid&&await(t.Security?.init(e)),t.Generator?.build(e.api)}stop(){const e=this;e.WebChannel?.stop(),e.SocketChannel?.stop(),e.Generator?.stop(),e.#ge=null,e.#ke=null,e.#de=null,e.#pe=null,e.#le=null}get api(){return this.Generator?.api||null}get isActive(){const e=this;return!(e.SocketChannel&&!e.SocketChannel.isOpen)&&!(!e.api||!e.Security)}get apiURL(){return this.cfg?.api||null}get serviceURL(){return this.cfg?.service||null}get cfg(){return this.#le}get isWSAPI(){return this.#fe}get isWebChannel(){return this.#ye}get isSocketChannel(){return this.#he}get Security(){return this.#pe}get Generator(){return this.#de}get WebChannel(){return this.#ge}get SocketChannel(){return this.#ke}get headers(){return this.#me}get querys(){return this.#Se}get id(){return this.#x}static async init(e){return new QuarkEngine(e).init()}}export{QuarkBuffer,QuarkEngine,QuarkEvent,QuarkGenerator,QuarkQueue,QuarkRequest,QuarkSecurity,QuarkSocketChannel,QuarkStreams,QuarkWebChannel};
//# sourceMappingURL=io.greenscreens.quark.esm.min.js.map
