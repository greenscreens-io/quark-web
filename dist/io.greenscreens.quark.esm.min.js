class Buffer{static from(e,t){switch(t){case'base64':return Buffer.fromBase64(e);case'hex':return Buffer.fromHex(e)}return e}static to(e,t){switch(t){case'base64':return Buffer.toBase64(e);case'hex':return Buffer.toHex(e)}return e}static fromHex(e){const t=[];for(let n=0;n<e.length;n+=2)t.push(parseInt('0x'+e.substr(n,2),16));return new Uint8Array(t)}static fromBase64(e){const t=atob(e),n=new ArrayBuffer(t.length),r=new Uint8Array(n);for(let e=0,n=t.length;e<n;e++)r[e]=t.charCodeAt(e);return r}static toHex(e){return Array.prototype.map.call(new Uint8Array(e),(e=>('00'+e.toString(16)).slice(-2))).join('')}static toBase64(e){return btoa(new Uint8Array(e))}}class Event extends EventTarget{#e=new Set;#t(e='',t){const n=Array.from(this.#e);return this.#n(t)?n.filter((n=>n.type===e&&n.listener===t)):n.filter((t=>t.type===e))}#n(e){return'function'==typeof e}addEventListener(e,t,n){return!!this.#n(t)&&(this.#e.add({type:e,listener:t}),super.addEventListener(e,t,n))}removeEventListener(e,t){const n=this,r=n.#t(e,t);r.forEach((e=>super.removeEventListener(e.type,e.listener))),r.forEach((e=>n.#e.delete(e)))}unbind(){Array.from(this.#e).forEach((e=>{super.removeEventListener(e.type,e.listener)})),this.#e.clear()}on(e='',t){return this.addEventListener(e,t)}once(e,t){let wrap=e=>{t(e),wrap=null};return wrap.type=e,wrap.listener=t,this.addEventListener(e,wrap,{once:!0})}off(e='',t){return this.removeEventListener(e,t)}emit(e,t){if(!e)return!1;const n=new CustomEvent(e,{detail:t});return this.dispatchEvent(n)}send(e,t){this.emit(e,t)}listen(e,t){this.on(e,t)}unlisten(e,t){this.off(e,t)}wait(t=''){if(!t)return e('Event undefined!');const n=this;return new Promise(((e,r)=>{n.once(t,(t=>e(t)))}))}static prevent(e){Event.#n(e,'preventDefault')&&e.preventDefault(),Event.#n(e,'stopPropagation')&&e.stopPropagation()}static{Object.freeze(Event)}}class Streams{static get isAvailable(){return'undefined'!=typeof CompressionStream&&'undefined'!=typeof DecompressionStream}static async compress(e,t='gzip'){const n=(new TextEncoder).encode(e),r=new CompressionStream(t),s=r.writable.getWriter();return s.write(n),s.close(),new Response(r.readable).arrayBuffer()}static async decompress(e,t='gzip'){const n=new DecompressionStream(t),r=n.writable.getWriter();r.write(e),r.close();const s=await new Response(n.readable).arrayBuffer();return(new TextDecoder).decode(s)}}class Security{#r=0;#s=null;#i=null;#a=null;#c=new TextEncoder;#o=new TextDecoder;getChallenge(e){return[e.challenge||'',e.keyEnc||'',e.keyVer||''].join('')}getRandom(e){const t=new Uint8Array(e);return crypto.getRandomValues(t),t}async generateAesKey(){return crypto.subtle.generateKey({name:'AES-CTR',length:128},!0,['encrypt','decrypt'])}async exportAesKey(e){const t=await crypto.subtle.exportKey('raw',e);return new Uint8Array(t)}async importRsaKey(e,t,n){const r=Buffer.from(e,'base64');return crypto.subtle.importKey('spki',r,t,!0,[n])}async verify(e,t,n){const r=Buffer.from(t,'base64'),s=this.#c.encode(n);return crypto.subtle.verify({name:'ECDSA',hash:{name:'SHA-384'}},e,r,s)}async encryptRSA(e){const t=this;let n=e;return'string'==typeof e&&(n=t.#c.encode(e)),crypto.subtle.encrypt('RSA-OAEP',t.#s,n)}async encryptAesMessage(e,t,n){const r=this.#c.encode(n),s={name:'AES-CTR',counter:t,length:128};return crypto.subtle.encrypt(s,e,r)}async decryptAesMessage(e,t,n){const r=Buffer.from(n,'hex'),s={name:'AES-CTR',counter:Buffer.from(t,'hex'),length:128};return crypto.subtle.decrypt(s,e,r)}get isValid(){return null!==this.#s&&null!==this.#i}static get isAvailable(){return null!=crypto.subtle}async init(e){const t=this;if(!Security.isAvailable)return;t.#r++,t.#s=await t.importRsaKey(e.keyEnc,{name:'RSA-OAEP',hash:'SHA-256'},'encrypt'),t.#i=await t.generateAesKey(),t.#a=await t.exportAesKey(t.#i);const n=await t.importRsaKey(e.keyVer,{name:'ECDSA',namedCurve:'P-384'},'verify');if(!await t.verify(n,e.signature,t.getChallenge(e||{})))throw t.#s=null,t.#i=null,t.#a=null,new Error('Signature invalid')}async encrypt(e,t){const n=this,r=n.getRandom(16),s=new Uint8Array(r.length+n.#a.length);s.set(r),s.set(n.#a,r.length);const i='string'==typeof e?e:JSON.stringify(e),a=await n.encryptRSA(s),c=await n.encryptAesMessage(n.#i,r,i);return!0===t?{t:'1',d:c,k:a}:{t:'1',d:Buffer.to(c,'hex'),k:Buffer.to(a,'hex')}}async decrypt(e){const t=this,n=e.iv,r=e.d,s=await t.decryptAesMessage(t.#i,n,r),i=t.#o.decode(s),a=JSON.parse(i);return a&&'ws'==a.type&&'data'===a.cmd?a.data:a}static async init(e){const t=new Security;return await t.init(e),t}}class Queue extends Map{#l=0;#u=0;#d=0;updateRequest(e){const t=this;t.#d++,t.#l++,e.tid=t.#d.toString(),t.set(e.tid,e)}reset(){const e=this;e.#l>50&&e.#u>=e.#l&&(e.#l=0,e.#u=0,e.clear())}process(e){const t=this,n=[];if(Array.isArray(e))e.forEach((e=>{const n=t.execute(e);n&&unkown.push(n)}));else{const r=t.execute(e);r&&n.push(r)}return n}execute(e){const t=this,n=e.tid;let r=null;if(t.#u++,t.has(n)){const r=t.get(n);try{r.finish(e)}catch(e){r.finish(e)}finally{t.delete(n)}}else r=e;return t.reset(),r}}class Request{#h=0;#p=0;#y;constructor(e,t){const n=this;n.#y=t,n.#p=e,n.#f()}get(e,t,n){const r=this;return'timeout'===t?r.timeout:'finish'===t?r.callback.bind(r):e[t]}callback(e){const t=this;if(!t.timeout)return t.#m(),t.#y(e)}get timeout(){return!0===this.#p}#m(){0!==this.#h&&clearTimeout(this.#h)}#f(){const e=this;0!==e.#p&&(e.#h=setTimeout((()=>{e.#p=!0,e.#y(new Error('Call timeouted!'))}),e.#p))}static wrap(e,t,n){return new Proxy(e,new Request(t,n))}}class Generator extends Event{#w={};#h=null;#g=0;#p=0;constructor(e=0,t=0){super(),this.#h=e,this.#p=t}get api(){return this.#w}stop(){const e=this;e.off('call'),e.off('api'),e.off('raw'),e.off('error'),e.#S()}#b(e,t){for(let n in e){let r=e[n];'object'==typeof r?this.#b(r,t)&&(e[n]=null):r._id_===t&&(e[n]=null)}return 0===Object.values(e).filter((e=>null!=e)).length}#S(){const e=this;e.#b(e.#w,e.#h),e.#w={}}build(e){const t=e?e.api||e:null;return t&&this.#E(t),t}#E(e){const t=this;Array.isArray(e)?e.forEach((e=>t.#A(e))):t.#A(e)}#A(e){const t=this;let n=null,r=null;n=t.#v(e.namespace),n[e.action]||(n[e.action]={}),r=n[e.action],e.methods?.forEach((n=>t.#k(e.namespace,e.action,r,n,t.#h)))}#v(e){let t=globalThis,n=this.#w;return e.split('.').every((e=>(t[e]||(t[e]={}),t=t[e],n[e]||(n[e]=t),n=t,!0))),t}#k(e,t,n,r,s){const i=!1!==r.encrypt,a={n:e,c:t,m:r.name,l:r.len,e:i,i:s};n[r.name]=this.#C(a),n[r.name]._id_=s}#C(e){const t=this,n=e;return function(){const e=Array.prototype.slice.call(arguments);if(e.length!=n.l)throw new Error(`Invalid arguments length. Required (${n.l})`);const r={namespace:n.n,action:n.c,method:n.m,id:n.i,e:n.e,data:e,key:++t.#g,tid:0,ts:Date.now()};return Object.seal(r),new Promise(((e,n)=>{try{const s=Request.wrap(r,t.#p,(r=>{t.#R(r,e,n)}));t.emit('call',s)}catch(e){n(e)}}))}}#R(e,t,n){if(e instanceof Error)return n(e);const r=e.result||e;r.success?t(r.data?r.data:r):n(r)}static build(e,t,n){const r=new Generator(t,n);return r.build(e),r}}class SocketChannel extends Event{#x=new Queue;#O=null;#P=null;async init(e){const t=this;return t.stop(),t.#P=e,new Promise(((e,n)=>(t.#W(e,n),null)))}get isOpen(){const e=this;return null!=e.#O&&e.#O.readyState===e.#O.OPEN}stop(){const e=this;return null!=e.#O&&(e.#O.close(),e.#O=null,e.#P=null,!0)}#I(e){const t=Array.isArray(e.data)&&e.data.length>0&&!1!==e.e;return this.#P.Security.isValid&&t}async#K(e){const t=this;let n=null;if((e=e.detail).id!==t.#P.id)return;const r=t.#I(e);if(t.#x.updateRequest(e),r){const n=await t.#P.Security.encrypt(e.data),r=Object.assign({},t.#P.querys||{},n||{});e.data=[r]}const s={cmd:r?'enc':'data',type:'ws',data:[e]};if(n=JSON.stringify(s),!Streams.isAvailable)return t.#O.send(n);n=await Streams.compress(n),t.#O.send(n)}async#W(e,t){const n=this,r=n.#P,s=r.Generator,i=Date.now(),a=new URL(r.serviceURL);Object.assign({},r.headers||{});const c=Object.assign({},r.querys||{});c.q=i,c.c=Streams.isAvailable,Object.entries(c||{}).forEach((e=>{a.searchParams.append(e[0],encodeURIComponent(e[1]))})),n.#O=new WebSocket(a.toString(),['ws4is']),n.#O.binaryType='arraybuffer';const o=n.#K.bind(n);n.#O.onopen=a=>{if(n.emit('online',a),s.on('call',o),!r.isWSAPI)return e(!0);s.once('api',(async n=>{try{n.challenge=i,await r.registerAPI(n),e(!0)}catch(e){t(e)}}))},n.#O.onclose=e=>{s.off('call',o),n.stop(),n.emit('offline',e)},n.#O.onerror=e=>{s.off('call',o),t(e),n.stop(),n.emit('error',e)},n.#O.onmessage=e=>{n.#j(e.data)}}#B(e){return e.startsWith('{')&&e.endsWith('}')}#q(e){return e.startsWith('[')&&e.endsWith(']')}async#j(e){const t=this,n=t.#P.Generator;let r=null,s=e;try{e instanceof ArrayBuffer&&(s=await Streams.decompress(e));const i=s.trim();t.#B(i)||t.#q(i)?(r=JSON.parse(s),t.#U(r)):n.emit('raw',s)}catch(e){n.emit('error',e)}}async#U(e){const t=this;let n=null;const r=t.#P,s=r.Generator,i=r.Security;if('api'===e.cmd)return s.emit('api',e.data);if('err'===e.cmd)return s.emit('error',e.result);if('enc'===e.cmd){if(!i.isAvailable)return s.emit('error',new Error('Security available on https/wss only'));n=await i.decrypt(e)}if('data'===e.cmd&&(n=e.data),n){t.#x.process(n).forEach((e=>t.emit('message',e)))}else t.emit('message',n)}}class WebChannel{#P=null;async init(e){const t=this;t.#P&&t.stop(),t.#P=e;const n=e.Generator,r=await t.#L(e.apiURL);await e.registerAPI(r),e.isSockChannel||n.on('call',t.#G.bind(t))}stop(){const e=this.#P;if(this.#P=null,e.Generator.off('call'),!e.isSockChannel)try{fetch(e.serviceURL,{method:'delete'})}catch(e){}}async#G(e){const t=this;let n=null;if((e=e.detail).id===t.#P.id)try{n=await t.#K(t.#P,e),e.finish(n)}catch(t){e.finish(t)}}async#L(e){const t=e,n=this.#P,r=Date.now(),s=Object.assign({},n.headers||{},{'x-time':r}),i=await fetch(t,{method:'get',headers:s,credentials:'same-origin'}),a=await i.json();return a.challenge=r.toString(),a}async#T(e,t){const n=this.#P,r='application/json',s={Accept:r,'Content-Type':r},i=new URL(e),a=Object.assign({},n.headers||{},s),c=Object.assign({},n.querys||{}),o=Object.assign({},n.querys||{},t||{}),l={method:'post',headers:a,body:JSON.stringify(o)};Object.entries(c||{}).forEach((e=>{i.searchParams.append(e[0],encodeURIComponent(e[1]))}));const u=await fetch(i.toString(),l);return await u.json()}async#K(e,t){const n=e.Security,r=e.serviceURL,s=Array.isArray(t.data)&&t.data.length>0;let i=t;if(n.isValid&&s&&(i=await n.encrypt(t)),i=await this.#T(r,i),'err'==i.cmd)throw new Error(i.result.msg);if('enc'===i.cmd){if(!n.isValid)throw new Error('Security available on https/wss only');i=await n.decrypt(i)}return i}}class Engine{constructor(e){if(!(e=e||{}).api)throw new Error('API Url not defined!');if(!e.service)throw new Error('Service Url not defined!');const t=this;if(t.cfg=null,t.isWSAPI=!1,t.isWebChannel=!1,t.isSockChannel=!1,t.Security=null,t.Generator=null,t.WebChannel=null,t.SocketChannel=null,t.id=Date.now(),t.cfg=e,t.isWSAPI=e.api===e.service&&0==e.api.indexOf('ws'),t.headers=e.headers||{},t.querys=e.querys||{},t.isWebChannel=0===e.service.indexOf('http'),t.isSockChannel=0===e.service.indexOf('ws'),!1===(t.isWebChannel||t.isSockChannel))throw new Error('Invalid definition for Engine Remote Service')}async init(){const e=this;if(!e.isActive)return e.Security=new Security,e.Generator=new Generator(e.id),(e.isWebChannel||0==e.isWSAPI)&&(e.WebChannel=new WebChannel,await e.WebChannel.init(e)),e.isSockChannel&&(e.SocketChannel=new SocketChannel,await e.SocketChannel.init(e)),e}async registerAPI(e){const t=this;e.signature&&(t.Security?.isActive||await t.Security.init(e)),t.Generator?.build(e.api)}stop(){const e=this;e.WebChannel?.stop(),e.SocketChannel?.stop(),e.Generator?.stop(),e.WebChannel=null,e.SocketChannel=null,e.Generator=null,e.Security=null,e.cfg=null}get api(){return this.Generator?.api||null}get isActive(){const e=this;return!(e.SocketChannel&&!e.SocketChannel.isOpen)&&!(!e.api||!e.Security)}get apiURL(){return this.cfg?.api||null}get serviceURL(){return this.cfg?.service||null}static async init(e){return new Engine(e).init()}}export{Buffer,Engine,Event,Generator,Queue,Request,Security,SocketChannel as Socket,Streams,WebChannel as Web};
//# sourceMappingURL=io.greenscreens.quark.esm.min.js.map
