class Buffer{static#e=new TextEncoder;static#t=new TextDecoder;static validateData(e){let t=null;if(e instanceof Array)t=new Uint8Array(e);else if(e instanceof ArrayBuffer)t=new Uint8Array(e);else if(e instanceof Uint8Array)t=e;else if(e instanceof String||'string'==typeof e)t=Buffer.fromText(e);else{if(!e.toArrayBuffer)throw'Invalid input, must be String or ArrayBuffer or Uint8Array';t=new Uint8Array(e.toArrayBuffer())}return t}static isString(e){return'string'==typeof e}static isHexString(e){return!!Buffer.isString(e)&&/^[0-9A-Fa-f]+$/g.test(e)}static toBuffer(e,t=!1){const n=Buffer;return n.isString(e)&&(e=t?n.fromBase64(e):n.isHexString(e)?n.fromHex(e):n.fromText(e)),n.validateData(e)}static toText(e){return Buffer.isText(e)?e:Buffer.#t.decode(e)}static fromText(e){return Buffer.isText(e)?Buffer.#e.encode(e):e}static isText(e){return'string'==typeof e}static fromHex(e){const t=[];for(let n=0;n<e.length;n+=2)t.push(parseInt('0x'+e.substr(n,2),16));return new Uint8Array(t)}static toHex(e){return Array.prototype.map.call(new Uint8Array(e),(e=>('00'+e.toString(16)).slice(-2))).join('')}static fromBase64(e){const t=atob(e),n=new ArrayBuffer(t.length),r=new Uint8Array(n);for(let e=0,n=t.length;e<n;e++)r[e]=t.charCodeAt(e);return r}static toBase64(e){return globalThis.btoa(new Uint8Array(e))}}class EventExt extends EventTarget{#n=new Set;#r(e='',t){const n=Array.from(this.#n);return EventExt.#i(t)?n.filter((n=>n.type===e&&n.listener===t)):n.filter((t=>t.type===e))}addEventListener(e,t,n){return!!EventExt.#i(t)&&(this.#n.add({type:e,listener:t}),super.addEventListener(e,t,n))}removeEventListener(e,t){const n=this,r=n.#r(e,t);r.forEach((e=>super.removeEventListener(e.type,e.listener))),r.forEach((e=>n.#n.delete(e)))}unbind(){Array.from(this.#n).forEach((e=>{super.removeEventListener(e.type,e.listener)})),this.#n.clear()}on(e='',t){return this.addEventListener(e,t)}once(e,t){let wrap=e=>{t(e),wrap=null};return wrap.type=e,wrap.listener=t,this.addEventListener(e,wrap,{once:!0})}off(e='',t){return this.removeEventListener(e,t)}emit(e,t){if(!e)return!1;const n=new CustomEvent(e,{detail:t});return this.dispatchEvent(n)}send(e,t){this.emit(e,t)}listen(e,t){this.on(e,t)}unlisten(e,t){this.off(e,t)}wait(t=''){if(!t)return e('Event undefined!');const n=this;return new Promise(((e,r)=>{n.once(t,(t=>e(t)))}))}static#i(e){return'function'==typeof e}static prevent(e){EventExt.#i(e,'preventDefault')&&e.preventDefault(),EventExt.#i(e,'stopPropagation')&&e.stopPropagation()}static{Object.freeze(Event)}}class Streams{static get isAvailable(){return'undefined'!=typeof CompressionStream&&'undefined'!=typeof DecompressionStream}static#s(e,t=!1,n=!1){if(!e instanceof Uint8Array)return e;const r=Streams.#a(t,n),i=new Uint8Array(8+e.length),s=new DataView(i.buffer);return s.setUint8(0,71),s.setUint8(1,83),s.setUint8(2,5),s.setUint8(3,r),s.setUint32(4,e.length),i.set(e,8),i}static async wrap(e,t){return e=Streams.toBinary(e),e=await Streams.compressOrDefault(e),e=await t.encrypt(e),e=Streams.#s(e,t.isValid,Streams.isAvailable)}static async unwrap(e,t){e instanceof Uint8Array&&(e=e.buffer);const n=new DataView(e),r=Streams.#c(n);if(e=Streams.toBinary(e),!r)return e;const i=n.getUint8(3),s=n.getUint32(4);if(n.byteLength!==s+8)return e;e=e.slice(8);const a=Streams.isCompressFlag(i);if(Streams.isEncryptFlag(i)&&(e=await(t?.decrypt(e))),a&&(e=await Streams.decompress(e).arrayBuffer()),e=Streams.toBinary(e),!Streams.isJson(e))throw new Error('Invalid response');return JSON.parse(Buffer.toText(e))}static#c(e){return e.byteLength>8&&18259===e.getUint16(0)&&5===e.getUint8(2)}static isCompressFlag(e){return 1==(1&e)}static isEncryptFlag(e){return 2==(2&e)}static#a(e,t){return(t?1:0)|(e?2:0)}static#o(e,t){const n=this.toBinary(e),r=t.writable.getWriter();return r.write(n),r.close(),new Response(t.readable)}static async compressOrDefault(e,t='gzip'){if(!Streams.isAvailable)return e;const n=await Streams.compress(e,t).arrayBuffer();return Streams.toBinary(n)}static async decompressOrDefault(e,t='gzip'){if(!Streams.isAvailable)return e;const n=await Streams.decompress(e,t).arrayBuffer();return Streams.toBinary(n)}static compress(e,t='gzip'){const n=new CompressionStream(t);return this.#o(e,n)}static decompress(e,t='gzip'){const n=new DecompressionStream(t);return this.#o(e,n)}static toBinary(e){return e instanceof Uint8Array?e:e instanceof ArrayBuffer?new Uint8Array(e):'string'==typeof e?Buffer.fromText(e):this.toBinary(JSON.stringify(e))}static isCompressed(e){const t=this;return e=t.toBinary(e),t.isGzip(e)||t.isZlib(e)}static isGzip(e){return 31===e.at(0)&&139===e.at(1)&&8===e.at(2)}static isZlib(e){return 120===e.at(0)&&[1,94,156,218].indexOf(e.at(1))>-1}static isJson(e){const t=this,n=(e='string'==typeof e?e.trim():t.toBinary(e)).at(0),r=e.at(e.length-1);return t.#l(n,r)||t.#u(n,r)}static#u(e,t){return!('{'!==e&&123!==e||'}'!==t&&125!==t)}static#l(e,t){return!('['!==e&&91!==e||']'!==t&&93!==t)}}class Security{static#f={name:'ECDH',namedCurve:'P-256'};static#y={name:'AES-CTR',length:256};#h=null;#p=null;get publicKey(){return this.#h}cookie(e='/'){return`gs-public-key=${this.#h||''};path=${e}`}updateCookie(e='/'){document.cookie=this.cookie(e)}#d(e){return[e.challenge||'',e.keyEnc||'',e.keyVer||''].join('')}async importKey(e,t,n){const r=Buffer.fromBase64(e),i=n?n.split(','):[];return crypto.subtle.importKey('spki',r,t,!0,i)}async exportKey(e){const t=await crypto.subtle.exportKey('raw',e);return Buffer.toHex(t)}async verify(e,t,n){t=Buffer.fromBase64(t),n=Buffer.toBuffer(n);return crypto.subtle.verify({name:'ECDSA',hash:{name:'SHA-384'}},e,t,n)}async#g(e){const t=this,n=await t.importKey(e.keyVer,{name:'ECDSA',namedCurve:'P-384'},'verify');if(!await t.verify(n,e.signature,t.#d(e)))throw new Error('Signature invalid')}#m(e){return this.importKey(e.keyEnc,Security.#f,'')}#w(){return crypto.subtle.generateKey(Security.#f,!0,['deriveKey','deriveBits'])}#S(e,t){const n={name:'ECDH',public:t},r=Security.#y;return crypto.subtle.deriveKey(n,e,r,!1,['encrypt','decrypt'])}#b(e){e=Buffer.toBuffer(e);const t=Object.assign({counter:e},Security.#y);return t.length=128,t}getRandom(e){const t=new Uint8Array(e);return crypto.getRandomValues(t),t}async encryptRaw(e,t,n){const r=Buffer.toBuffer(n),i=this.#b(t);return crypto.subtle.encrypt(i,e,r)}async decryptRaw(e,t,n){const r=Buffer.toBuffer(n),i=this.#b(t);return crypto.subtle.decrypt(i,e,r)}async decryptAsBuffer(e,t,n){const r=await this.decryptRaw(e,t,n);return Buffer.toBuffer(r)}async encryptAsBuffer(e,t,n){const r=await this.encryptRaw(e,t,n);return Buffer.toBuffer(r)}async decryptAsString(e,t,n){const r=await this.decryptRaw(e,t,n);return Buffer.toText(r)}async encryptAsHex(e,t,n){const r=await this.encryptRaw(e,t,n);return Buffer.toHex(r)}get isValid(){return null!==this.#h&&null!==this.#p}static get isAvailable(){return!!crypto.subtle}async init(e){if(!Security.isAvailable)return;const t=this;await t.#g(e);const n=await t.#m(e),r=await t.#w();t.#h=await t.exportKey(r.publicKey),t.#p=await t.#S(r.privateKey,n)}async encrypt(e){const t=this;if(!t.isValid)return e;if(!e instanceof Uint8Array)return e;const n=t.getRandom(16),r=await t.encryptAsBuffer(t.#p,n,e),i=new Uint8Array(n.length+r.length);return i.set(n,0),i.set(r,n.length),i}async decrypt(e,t){return t||(t=e.slice(0,16),e=e.slice(16)),await this.decryptAsBuffer(this.#p,t,e)}static async init(e){const t=new Security;return await t.init(e),t}}class Queue extends Map{#A=0;#E=0;#C=0;updateRequest(e){const t=this;t.#C++,t.#A++,e.tid=t.#C.toString(),t.set(e.tid,e)}reset(){const e=this;e.#A>50&&e.#E>=e.#A&&(e.#A=0,e.#E=0,e.clear())}process(e){const t=this,n=[];if(Array.isArray(e))e.forEach((e=>{const n=t.execute(e);n&&unkown.push(n)}));else{const r=t.execute(e);r&&n.push(r)}return n}execute(e){const t=this,n=e.tid;let r=null;if(t.#E++,t.has(n)){const r=t.get(n);try{r.finish(e)}catch(e){r.finish(e)}finally{t.delete(n)}}else r=e;return t.reset(),r}}class Request{#v=0;#B=0;#k;constructor(e,t){const n=this;n.#k=t,n.#B=e,n.#x()}get(e,t){const n=this;return'timeout'===t?n.timeout:'finish'===t?n.callback.bind(n):e[t]}callback(e){const t=this;if(!t.timeout)return t.#I(),t.#k(e)}get timeout(){return!0===this.#B}#I(){0!==this.#v&&clearTimeout(this.#v)}#x(){const e=this;0!==e.#B&&(e.#v=setTimeout((()=>{e.#B=!0,e.#k(new Error('Call timeouted!'))}),e.#B))}static wrap(e,t,n){return new Proxy(e,new Request(t,n))}}class Generator extends EventExt{#R={};#v=null;#P=0;#B=0;constructor(e=0,t=0){super(),this.#v=e,this.#B=t}get api(){return this.#R}stop(){const e=this;e.off('call'),e.off('api'),e.off('raw'),e.off('error'),e.#U()}#O(e,t){for(let n in e){let r=e[n];'object'==typeof r?this.#O(r,t)&&(e[n]=null):r._id_===t&&(e[n]=null)}return 0===Object.values(e).filter((e=>null!=e)).length}#U(){const e=this;e.#O(e.#R,e.#v),e.#R={}}build(e){const t=e?e.api||e:null;return t&&this.#W(t),t}#W(e){const t=this;Array.isArray(e)?e.forEach((e=>t.#T(e))):t.#T(e)}#T(e){const t=this;let n=null,r=null;n=t.#M(e.namespace),n[e.action]||(n[e.action]={}),r=n[e.action],t.#K(e.methods)?.forEach((n=>t.#G(e.namespace,e.action,r,n,t.#v)))}#K(e){return e.reduce(((e,t,n,r)=>{if(1==e.filter((e=>e.name==t.name)).length)return e;const i=r.filter((e=>e.name==t.name));if(1===i.length)return e.push(t),e;const s=i.filter((e=>e.name===t.name)).reduce(((e,t)=>(e.len.push(t.len),e.async[t.len]=t.async,e)),{name:t.name,len:[],async:{}});return e.push(s),e}),[])}#M(e){let t=globalThis,n=this.#R;return e.split('.').every((e=>(t[e]||(t[e]={}),t=t[e],n[e]||(n[e]=t),n=t,!0))),t}#G(e,t,n,r,i){const s=!1!==r.encrypt,a={n:e,c:t,m:r.name,l:r.len,a:r.async,e:s,i};n[r.name]=this.#D(a),n[r.name]._id_=i}#D(e){const t=this,n=e;return function(){const e=Array.prototype.slice.call(arguments),r=Array.isArray(n.l),i=r?n.l.filter((t=>t===e.length)).pop():n.l;if(e.length!=i)throw new Error(`Invalid arguments length. Required (${n.l})`);const s=r?n.a[e.length]:n.a,a=s?0:t.#B,c={namespace:n.n,action:n.c,method:n.m,id:n.i,enc:n.e,data:e,key:++t.#P,tid:0,ts:Date.now()};return Object.seal(c),new Promise(((e,n)=>{try{const r=Request.wrap(c,a,(r=>{t.#q(r,e,n)}));t.emit('call',r)}catch(e){n(e)}}))}}#q(e,t,n){if(e instanceof Error)return n(e);const r=e.result||e;r.success?t(r):n(r)}static build(e,t,n){const r=new Generator(t,n);return r.build(e),r}}class SocketChannel extends EventExt{#j=new Queue;#J=null;#L=null;#_=0;async init(e){const t=this;return t.stop(),t.#L=e,new Promise(((e,n)=>(t.#N(e,n),null)))}get isOpen(){const e=this;return null!=e.#J&&e.#J.readyState===e.#J.OPEN}stop(){const e=this;return null!=e.#J&&(e.#J.close(),e.#J=null,e.#L=null,!0)}#H(e,t){const n={type:'GS',cmd:e,data:t?[t]:null};return JSON.stringify(n)}get#F(){return this.#H('ping')}async#V(e){const t=this;if((e=e.detail).id!==t.#L.id)return;t.#j.updateRequest(e);const n=t.#H('data',e),r=await Streams.wrap(n,t.#L.Security);t.#J.send(r)}async#N(e,t){const n=this,r=n.#L,i=r.Generator,s=r.Security,a=Date.now(),c=new URL(r.serviceURL),o=Object.assign({},r.querys||{});o.q=a,o.c=Streams.isAvailable,Object.entries(o||{}).forEach((e=>{e[1]&&c.searchParams.append(e[0],encodeURIComponent(e[1]))})),s.updateCookie(),n.#J=new WebSocket(c.toString(),['quark']),n.#J.binaryType='arraybuffer';const l=n.#V.bind(n);n.#J.onopen=s=>{if(n.emit('online',s),i.on('call',l),n.#Y(),!r.isWSAPI)return e(!0);i.once('api',(async n=>{try{n.challenge=a,await r.registerAPI(n),e(!0)}catch(e){t(e)}}))},n.#J.onclose=e=>{i.off('call',l),clearInterval(n.#_),n.stop(),n.emit('offline',e)},n.#J.onerror=e=>{i.off('call',l),t(e),n.stop(),n.emit('error',e)},n.#J.onmessage=async e=>{try{e.data instanceof ArrayBuffer?await n.#z(e.data):await n.#Q(e.data)}catch(t){t.data=e,i.emit('error',t)}}}#Y(){const e=this;e.#_=setInterval((()=>{e.send(e.#F)}),15e3)}async#z(e){const t=this,n=t.#L.Security;e=await Streams.unwrap(e,n);if(!Streams.isJson(e))return generator.emit('raw',e);Array.isArray(e)?e.forEach((e=>t.#$(e))):t.#$(e)}async#Q(e){const t=this,n=t.#L.Generator;try{if(!Streams.isJson(e))return n.emit('raw',e);e=JSON.parse(e),Array.isArray(e)?e.forEach((e=>t.#$(e))):t.#$(obj)}catch(e){n.emit('error',e)}}async#$(e){const t=this;let n=null;const r=t.#L.Generator;if('api'===e.cmd)return r.emit('api',e.data);if('err'===e.cmd)return r.emit('error',e.result);if('data'===e.cmd&&(n=e.data),n){t.#j.process(n).forEach((e=>t.emit('message',e)))}else t.emit('message',n)}}class WebChannel{static#Z='application/octet-stream';static#X='application/json';#L=null;async init(e){const t=this;t.#L&&t.stop(),t.#L=e;const n=e.Generator,r=await t.#ee(e.apiURL);await e.registerAPI(r),e.isSocketChannel||n.on('call',t.#te.bind(t))}stop(){const e=this.#L;if(this.#L=null,e.Generator.off('call'),!e.isSocketChannel)try{fetch(e.serviceURL,{method:'delete'})}catch(e){}}async#te(e){const t=this;let n=null;if((e=e.detail).id===t.#L.id)try{n=await t.#V(t.#L,e),e.finish(n)}catch(t){e.finish(t)}}async#ee(e){const t=e,n=this.#L,r=Date.now(),i=Object.assign({},n.headers||{},{'x-time':r}),s=await fetch(t,{method:'get',headers:i,credentials:'same-origin'}),a=await s.json();return a.challenge=r.toString(),a}get#ne(){return`${WebChannel.#Z}, ${WebChannel.#X}`}#re(e){return'string'!=typeof e?WebChannel.#Z:WebChannel.#X}async#ie(e,t,n,r){const i=this,s=i.#L,a=i.#re(t),c={Accept:i.#ne,'Content-Type':a,'Accept-Encoding':'gzip,deflate,br'};r&&Streams.isAvailable&&(t=Streams.toBinary(t),t=await Streams.compressOrDefault(t),c['Content-Encoding']='gzip');const o=new URL(e),l=Object.assign({},s.headers||{},c,n||{}),u=Object.assign({},s.querys||{}),f={method:'post',headers:l,body:t};return Object.entries(u||{}).forEach((e=>{o.searchParams.append(e[0],encodeURIComponent(e[1]))})),await fetch(o.toString(),f)}async#q(e){const t=e.headers.get('content-type')||'',n=t.includes(WebChannel.#Z),r=t.includes(WebChannel.#X),i=!n&&!r;if(r)return await e.json();if(i){const t=await e.text();if(!Streams.isJson(t))throw new Error('Invalid response');return JSON.parse(t)}const s=await e.arrayBuffer(),a=await Streams.unwrap(s,this.#L.Security);return a&&'ws'==a.type&&'data'===a.cmd?a.data:a}async#V(e,t){const n=this,r=e.Security,i=e.serviceURL,s=r?.isValid;let a=!1,c=null;s?c=await Streams.wrap(t,n.#L.Security):(c=JSON.stringify(c),a=!0);const o={};s&&(o['gs-public-key']=r.publicKey);const l=await n.#ie(i,c,o,a),u=await n.#q(l);if('err'==u.cmd)throw new Error(u.result.msg);return u}}class QuarkEngine{#se=null;#ae=!1;#ce=!1;#oe=!1;#le=null;#ue=null;#fe=null;#ye=null;#he=null;#pe=null;#v=null;constructor(e){if(!(e=e||{}).api)throw new Error('API Url not defined!');if(!e.service)throw new Error('Service Url not defined!');const t=this;if(t.#se=null,t.#ae=!1,t.#ce=!1,t.#oe=!1,t.#le=null,t.#ue=null,t.#fe=null,t.#ye=null,t.#v=Date.now(),t.#se=e,t.#ae=e.api===e.service&&0==e.api.indexOf('ws'),t.#he=e.headers||{},t.#pe=e.querys||{},t.#ce=0===e.service.indexOf('http'),t.#oe=0===e.service.indexOf('ws'),!1===(t.isWebChannel||t.isSocketChannel))throw new Error('Invalid definition for Engine Remote Service')}async init(){const e=this;if(!e.isActive)return e.#le=new Security,e.#ue=new Generator(e.id),(e.isWebChannel||0==e.isWSAPI)&&(e.#fe=new WebChannel,await e.WebChannel.init(e)),e.isSocketChannel&&(e.#ye=new SocketChannel,await e.SocketChannel.init(e)),e}async registerAPI(e){const t=this;e.signature&&await(t.Security?.init(e)),t.Generator?.build(e.api)}stop(){const e=this;e.WebChannel?.stop(),e.SocketChannel?.stop(),e.Generator?.stop(),e.#fe=null,e.#ye=null,e.#ue=null,e.#le=null,e.#se=null}get api(){return this.Generator?.api||null}get isActive(){const e=this;return!(e.SocketChannel&&!e.SocketChannel.isOpen)&&!(!e.api||!e.Security)}get apiURL(){return this.cfg?.api||null}get serviceURL(){return this.cfg?.service||null}get cfg(){return this.#se}get isWSAPI(){return this.#ae}get isWebChannel(){return this.#ce}get isSocketChannel(){return this.#oe}get Security(){return this.#le}get Generator(){return this.#ue}get WebChannel(){return this.#fe}get SocketChannel(){return this.#ye}get headers(){return this.#he}get querys(){return this.#pe}get id(){return this.#v}static async init(e){return new QuarkEngine(e).init()}}export{Buffer,EventExt,Generator,QuarkEngine,Queue,Request,Security,SocketChannel,Streams,WebChannel};
//# sourceMappingURL=io.greenscreens.quark.esm.min.js.map
